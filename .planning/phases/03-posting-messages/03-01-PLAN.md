---
phase: 03-posting-messages
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - discord-bridge/src/discord-client.ts
  - discord-bridge/src/types.ts
  - discord-bridge/src/index.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/channels/:channelId/messages accepts content and username, returns Discord message object"
    - "Webhook URL is never exposed in any API response or client-facing code"
    - "Username has ' (unverified)' appended server-side before sending to Discord"
    - "Missing content, missing username, content >2000 chars, or username containing 'clyde' returns 400"
    - "Missing webhook config returns 503 with clear error message"
  artifacts:
    - path: "discord-bridge/src/discord-client.ts"
      provides: "executeWebhook function, getWebhookUrl helper, WebhookPayload type"
      exports: ["executeWebhook"]
    - path: "discord-bridge/src/index.ts"
      provides: "POST /api/channels/:channelId/messages endpoint"
      contains: "app.post"
    - path: "discord-bridge/src/types.ts"
      provides: "WebhookPayload interface"
      contains: "WebhookPayload"
  key_links:
    - from: "discord-bridge/src/index.ts"
      to: "discord-bridge/src/discord-client.ts"
      via: "import executeWebhook"
      pattern: "executeWebhook\\(channelId"
    - from: "discord-bridge/src/discord-client.ts"
      to: "Discord webhook API"
      via: "fetch to webhook URL with ?wait=true"
      pattern: "webhookUrl.*\\?wait=true"
---

<objective>
Add a webhook proxy endpoint to the discord-bridge sidecar that accepts messages from the browser and forwards them to Discord via webhook.

Purpose: Enables the browser to post messages to Discord without ever seeing the webhook URL (INFRA-03, POST-03). The bridge appends " (unverified)" to the display name server-side.
Output: Working POST endpoint at /api/channels/:channelId/messages that validates input, constructs the webhook payload, and returns the created Discord message.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-posting-messages/03-RESEARCH.md
@.planning/phases/03-posting-messages/03-CONTEXT.md
@discord-bridge/src/index.ts
@discord-bridge/src/discord-client.ts
@discord-bridge/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WebhookPayload type and executeWebhook function</name>
  <files>discord-bridge/src/types.ts, discord-bridge/src/discord-client.ts</files>
  <action>
In `discord-bridge/src/types.ts`, add a `WebhookPayload` interface:
```typescript
export interface WebhookPayload {
  content: string;
  username: string;
  avatar_url?: string;
}
```

In `discord-bridge/src/discord-client.ts`, add webhook URL resolution and execution:

1. At module level, parse `DISCORD_WEBHOOK_MAP` env var (JSON object mapping channelId to webhook URL) and read `DISCORD_WEBHOOK_URL` as default fallback:
```typescript
const WEBHOOK_MAP: Record<string, string> = (() => {
  const mapStr = process.env.DISCORD_WEBHOOK_MAP;
  if (mapStr) {
    try { return JSON.parse(mapStr); } catch { /* fall through */ }
  }
  return {};
})();
const DEFAULT_WEBHOOK_URL = process.env.DISCORD_WEBHOOK_URL;
```

2. Add `getWebhookUrl(channelId: string): string` helper that looks up `WEBHOOK_MAP[channelId]`, falls back to `DEFAULT_WEBHOOK_URL`, throws Error with clear message if neither exists.

3. Add `validateWebhookUsername(username: string): string | null` function that returns an error message string if invalid, null if valid. Rules:
   - Must be 1-80 chars after trimming
   - Must not contain "clyde" (case-insensitive substring match)
   - The 80-char limit applies to the FINAL username (after " (unverified)" suffix is appended by the caller in index.ts), but this function validates the raw input before suffix. The POST endpoint handles the suffix.

4. Export `executeWebhook(channelId: string, payload: WebhookPayload): Promise<{ id: string }>` function:
   - Calls `getWebhookUrl(channelId)` to resolve the webhook URL
   - POSTs to `${webhookUrl}?wait=true` with JSON body containing `content`, `username`, and optionally `avatar_url`
   - Uses the existing `handleResponse<T>()` helper to handle 429/error responses
   - Returns the created message object (at minimum `{ id: string }`)

Important: Do NOT use the bot token or `authHeaders()` for webhook execution. Webhooks use their own URL-embedded token. The fetch call should use `{ 'Content-Type': 'application/json' }` as the only header.

Also export `validateWebhookUsername` for use by the POST endpoint.
  </action>
  <verify>
Run `cd /home/penguin/code/lens-relay/ws1/discord-bridge && npx tsc --noEmit` to verify TypeScript compiles without errors.
  </verify>
  <done>
`executeWebhook` and `validateWebhookUsername` are exported from discord-client.ts. `WebhookPayload` type exists in types.ts. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add POST webhook proxy endpoint</name>
  <files>discord-bridge/src/index.ts</files>
  <action>
Add a POST endpoint to `discord-bridge/src/index.ts`. Import `executeWebhook` and `validateWebhookUsername` from `./discord-client.js`. Import `WebhookPayload` from `./types.js` if needed.

Add the endpoint AFTER the existing GET endpoints (before port detection code):

```typescript
app.post('/api/channels/:channelId/messages', async (c) => { ... });
```

Implementation:
1. Parse the JSON body with `c.req.json<{ content: string; username: string }>()`. Wrap in try/catch to return 400 on malformed JSON.

2. Validate required fields:
   - `body.content?.trim()` must be non-empty, else return 400 `{ error: 'Message content is required' }`
   - `body.username?.trim()` must be non-empty, else return 400 `{ error: 'Username is required' }`

3. Validate content length: if `body.content.length > 2000`, return 400 `{ error: 'Message exceeds 2000 character limit' }`

4. Construct the final username: `${body.username.trim()} (unverified)` -- this satisfies POST-03

5. Validate the FINAL username (with suffix) using `validateWebhookUsername`. If invalid, return 400 with the validation error.

6. Call `executeWebhook(channelId, { content: body.content, username: finalUsername })` inside try/catch.

7. Error handling follows the exact same pattern as existing GET endpoints:
   - `RateLimitError` -> 429 with `{ error: 'Rate limited', retryAfter: err.retryAfter }`
   - `DiscordApiError` -> forward status code with `{ error: 'Discord API error', details: err.body }`
   - Generic Error with message containing "No webhook URL configured" -> 503 with `{ error: err.message }`
   - Other errors -> 500 with `{ error: message }`

8. On success, return `c.json(result, 200)` where result is the Discord message object.

Also add a startup warning log if no webhook URL is configured (after `startGateway()` call):
```typescript
if (!process.env.DISCORD_WEBHOOK_URL && !process.env.DISCORD_WEBHOOK_MAP) {
  console.warn('[discord-bridge] No webhook URL configured. POST /api/channels/:channelId/messages will return 503.');
  console.warn('[discord-bridge] Set DISCORD_WEBHOOK_URL or DISCORD_WEBHOOK_MAP to enable message posting.');
}
```
  </action>
  <verify>
1. Run `cd /home/penguin/code/lens-relay/ws1/discord-bridge && npx tsc --noEmit` -- TypeScript compiles cleanly.
2. Start the bridge: `cd /home/penguin/code/lens-relay/ws1/discord-bridge && DISCORD_BOT_TOKEN=test npm run dev &` (it will fail to connect to Discord but the HTTP server starts).
3. Test validation:
   - `curl -s -X POST http://localhost:8091/api/channels/123/messages -H 'Content-Type: application/json' -d '{}'` should return 400 with "content is required" or "username is required"
   - `curl -s -X POST http://localhost:8091/api/channels/123/messages -H 'Content-Type: application/json' -d '{"content":"test","username":"clydebot"}'` should return 400 (clyde validation)
4. Stop the bridge after testing.
  </verify>
  <done>
POST /api/channels/:channelId/messages endpoint exists, validates input (empty fields, content length, clyde check), appends " (unverified)" to username, calls executeWebhook, and returns appropriate error codes. Startup warning logged when no webhook URL is configured.
  </done>
</task>

</tasks>

<verification>
- TypeScript compiles: `cd discord-bridge && npx tsc --noEmit`
- POST endpoint responds to curl with proper validation errors
- Webhook URL is never present in any API response body
- The string " (unverified)" is appended to username in the endpoint handler before passing to executeWebhook
</verification>

<success_criteria>
- POST /api/channels/:channelId/messages accepts `{ content, username }` and validates both fields
- Content >2000 chars returns 400
- Username containing "clyde" returns 400
- Missing webhook URL returns 503
- On success, the endpoint returns the Discord message object
- Username sent to Discord is always `DisplayName (unverified)`
</success_criteria>

<output>
After completion, create `.planning/phases/03-posting-messages/03-01-SUMMARY.md`
</output>
