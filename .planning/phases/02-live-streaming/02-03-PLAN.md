---
phase: 02-live-streaming
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - lens-editor/src/components/DiscussionPanel/useMessages.ts
  - lens-editor/src/components/DiscussionPanel/useAutoScroll.ts
  - lens-editor/src/components/DiscussionPanel/NewMessagesBar.tsx
  - lens-editor/src/components/DiscussionPanel/MessageList.tsx
  - lens-editor/src/components/DiscussionPanel/DiscussionPanel.tsx
autonomous: false

must_haves:
  truths:
    - "New messages posted in Discord appear in the panel within 2 seconds without page reload"
    - "Panel auto-scrolls to show new messages when the user is at the bottom"
    - "When user scrolls up, auto-scroll stops and new messages accumulate without disrupting reading position"
    - "A 'new messages' indicator appears at the bottom when scrolled up and new messages arrive"
    - "Clicking the 'new messages' indicator scrolls to the bottom and dismisses the indicator"
    - "Duplicate messages do not appear (SSE + REST overlap is handled)"
    - "Switching documents closes the previous SSE connection and opens a new one"
  artifacts:
    - path: "lens-editor/src/components/DiscussionPanel/useMessages.ts"
      provides: "SSE subscription after initial REST fetch, with deduplication"
      contains: "EventSource"
    - path: "lens-editor/src/components/DiscussionPanel/useAutoScroll.ts"
      provides: "IntersectionObserver-based auto-scroll with unseen message counter"
      exports: ["useAutoScroll"]
    - path: "lens-editor/src/components/DiscussionPanel/NewMessagesBar.tsx"
      provides: "Floating indicator bar showing count of unseen messages"
      exports: ["NewMessagesBar"]
    - path: "lens-editor/src/components/DiscussionPanel/MessageList.tsx"
      provides: "Sentinel element for IntersectionObserver, relative positioning for indicator"
      contains: "sentinelRef"
    - path: "lens-editor/src/components/DiscussionPanel/DiscussionPanel.tsx"
      provides: "Gateway status display in header"
      contains: "gatewayStatus"
  key_links:
    - from: "lens-editor/src/components/DiscussionPanel/useMessages.ts"
      to: "/api/discord/channels/:channelId/events"
      via: "EventSource connection after initial fetch"
      pattern: "new EventSource"
    - from: "lens-editor/src/components/DiscussionPanel/useMessages.ts"
      to: "lens-editor/src/components/DiscussionPanel/useMessages.ts"
      via: "Deduplication by message ID before appending"
      pattern: "some.*m\\.id.*===.*newMsg\\.id"
    - from: "lens-editor/src/components/DiscussionPanel/MessageList.tsx"
      to: "lens-editor/src/components/DiscussionPanel/useAutoScroll.ts"
      via: "sentinelRef and containerRef from useAutoScroll hook"
      pattern: "useAutoScroll"
    - from: "lens-editor/src/components/DiscussionPanel/MessageList.tsx"
      to: "lens-editor/src/components/DiscussionPanel/NewMessagesBar.tsx"
      via: "Renders NewMessagesBar when unseenCount > 0"
      pattern: "<NewMessagesBar"
---

<objective>
Wire the browser to the SSE endpoint for live message streaming, add smart auto-scroll with IntersectionObserver, and add a "new messages" indicator bar.

Purpose: This is the core user-facing feature of Phase 2. After loading history (Phase 1), new Discord messages appear in real time. The auto-scroll behavior respects the user's reading position -- scrolling to new messages when at the bottom, pausing when scrolled up with a clickable indicator to jump to latest.

Output: Live-updating message list with auto-scroll behavior and new messages indicator.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-live-streaming/02-RESEARCH.md
@.planning/phases/02-live-streaming/02-01-SUMMARY.md

@lens-editor/src/components/DiscussionPanel/useMessages.ts
@lens-editor/src/components/DiscussionPanel/MessageList.tsx
@lens-editor/src/components/DiscussionPanel/DiscussionPanel.tsx
@lens-editor/src/components/DiscussionPanel/DiscussionPanel.test.tsx
@lens-editor/vite.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend useMessages with SSE subscription and create auto-scroll hook + indicator</name>
  <files>
    lens-editor/src/components/DiscussionPanel/useMessages.ts
    lens-editor/src/components/DiscussionPanel/useAutoScroll.ts
    lens-editor/src/components/DiscussionPanel/NewMessagesBar.tsx
  </files>
  <action>
    **1. Extend `useMessages.ts` with SSE subscription:**

    Add a new `gatewayStatus` field to `UseMessagesResult`:
    ```
    gatewayStatus: 'connected' | 'connecting' | 'disconnected' | 'reconnecting';
    ```

    Add state: `const [gatewayStatus, setGatewayStatus] = useState<...>('disconnected');`

    Add a SECOND useEffect (after the existing fetch effect) that manages the SSE connection:

    ```
    useEffect(() => {
      if (!channelId) {
        setGatewayStatus('disconnected');
        return;
      }

      const eventSource = new EventSource(`/api/discord/channels/${channelId}/events`);
      setGatewayStatus('connecting');

      eventSource.addEventListener('message', (e) => {
        const newMsg: DiscordMessage = JSON.parse(e.data);
        setMessages((prev) => {
          // Dedup: skip if message ID already exists
          if (prev.some((m) => m.id === newMsg.id)) return prev;
          return [...prev, newMsg];
        });
      });

      eventSource.addEventListener('status', (e) => {
        const { gateway } = JSON.parse(e.data);
        setGatewayStatus(gateway);
      });

      eventSource.addEventListener('heartbeat', () => {
        // Heartbeat received, connection is alive. No action needed.
      });

      eventSource.onopen = () => {
        setGatewayStatus('connected');
      };

      eventSource.onerror = () => {
        // EventSource auto-reconnects. Update status for UI.
        setGatewayStatus('reconnecting');
      };

      return () => {
        eventSource.close();
        setGatewayStatus('disconnected');
      };
    }, [channelId]);
    ```

    IMPORTANT: The SSE effect depends ONLY on `channelId` (not `fetchTrigger`). The SSE connection should persist across refetch calls. The refetch function re-fetches history but doesn't reconnect SSE.

    IMPORTANT: The deduplication uses `prev.some((m) => m.id === newMsg.id)` inside the `setMessages` updater function. This ensures the check uses the latest state, avoiding stale closure issues.

    Return `gatewayStatus` from the hook.

    **2. Create `useAutoScroll.ts`:**

    Create `lens-editor/src/components/DiscussionPanel/useAutoScroll.ts`:

    ```typescript
    import { useRef, useState, useCallback, useEffect } from 'react';

    interface AutoScrollResult {
      sentinelRef: React.RefObject<HTMLDivElement | null>;
      containerRef: React.RefObject<HTMLDivElement | null>;
      isAtBottom: boolean;
      scrollToBottom: () => void;
      unseenCount: number;
      resetUnseen: () => void;
    }

    export function useAutoScroll(messageCount: number): AutoScrollResult {
      const sentinelRef = useRef<HTMLDivElement>(null);
      const containerRef = useRef<HTMLDivElement>(null);
      const [isAtBottom, setIsAtBottom] = useState(true);
      const [unseenCount, setUnseenCount] = useState(0);
      const prevCountRef = useRef(messageCount);

      // Track whether sentinel is visible via IntersectionObserver
      useEffect(() => {
        const sentinel = sentinelRef.current;
        if (!sentinel) return;

        const observer = new IntersectionObserver(
          ([entry]) => {
            setIsAtBottom(entry.isIntersecting);
            if (entry.isIntersecting) {
              setUnseenCount(0);
            }
          },
          { threshold: 0.1 }
        );

        observer.observe(sentinel);
        return () => observer.disconnect();
      }, []);

      // When new messages arrive, auto-scroll or increment unseen
      useEffect(() => {
        const newCount = messageCount - prevCountRef.current;
        prevCountRef.current = messageCount;

        if (newCount <= 0) return;

        if (isAtBottom) {
          sentinelRef.current?.scrollIntoView({ behavior: 'smooth' });
        } else {
          setUnseenCount((c) => c + newCount);
        }
      }, [messageCount, isAtBottom]);

      const scrollToBottom = useCallback(() => {
        sentinelRef.current?.scrollIntoView({ behavior: 'smooth' });
        setUnseenCount(0);
      }, []);

      const resetUnseen = useCallback(() => setUnseenCount(0), []);

      return { sentinelRef, containerRef, isAtBottom, scrollToBottom, unseenCount, resetUnseen };
    }
    ```

    **3. Create `NewMessagesBar.tsx`:**

    Create `lens-editor/src/components/DiscussionPanel/NewMessagesBar.tsx`:

    ```typescript
    interface NewMessagesBarProps {
      count: number;
      onClick: () => void;
    }

    export function NewMessagesBar({ count, onClick }: NewMessagesBarProps) {
      if (count === 0) return null;

      return (
        <button
          onClick={onClick}
          className="absolute bottom-2 left-1/2 -translate-x-1/2 px-3 py-1.5 bg-blue-600 text-white text-xs font-medium rounded-full shadow-lg hover:bg-blue-700 transition-colors z-10"
          data-testid="new-messages-bar"
        >
          {count === 1 ? '1 new message' : `${count} new messages`}
        </button>
      );
    }
    ```

    AVOID: Do NOT implement custom SSE reconnection logic. The browser's EventSource API auto-reconnects with exponential backoff. Only update the UI status on error.

    AVOID: Do NOT add the SSE `channelId` dependency to the fetch effect. Keep the two effects separate -- fetch is triggered by `channelId + fetchTrigger`, SSE is triggered by `channelId` only.
  </action>
  <verify>
    - `cd lens-editor && npx tsc --noEmit` passes
    - useMessages.ts returns `gatewayStatus` field
    - useMessages.ts has `new EventSource` with proper cleanup (`eventSource.close()`)
    - useAutoScroll.ts exports `useAutoScroll` with IntersectionObserver
    - NewMessagesBar.tsx exports `NewMessagesBar`
  </verify>
  <done>SSE subscription with deduplication is wired into useMessages, auto-scroll hook with IntersectionObserver is ready, and NewMessagesBar component exists.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate auto-scroll into MessageList and add gateway status to DiscussionPanel</name>
  <files>
    lens-editor/src/components/DiscussionPanel/MessageList.tsx
    lens-editor/src/components/DiscussionPanel/DiscussionPanel.tsx
  </files>
  <action>
    **1. Update `MessageList.tsx` to use auto-scroll:**

    - Import `useAutoScroll` from `./useAutoScroll`
    - Import `NewMessagesBar` from `./NewMessagesBar`
    - Remove the existing `bottomRef` and the `useEffect` that calls `scrollIntoView({ behavior: 'instant' })` on messages change. The auto-scroll hook replaces this.
    - Call `useAutoScroll(messages.length)` to get `{ sentinelRef, containerRef, scrollToBottom, unseenCount }`
    - Change the outer `<div>` to use `containerRef` and add `relative` positioning (for the absolute-positioned NewMessagesBar):
      ```
      <div ref={containerRef} className="flex-1 overflow-y-auto relative">
      ```
    - Replace the bottom `<div ref={bottomRef} />` with `<div ref={sentinelRef} className="h-1" />` (1px height sentinel for IntersectionObserver)
    - Add `<NewMessagesBar count={unseenCount} onClick={scrollToBottom} />` inside the container div, after the messages but before the sentinel. Or after the sentinel -- the absolute positioning makes it float regardless. Place it as the last child before the closing `</div>`.
    - Keep the initial scroll-to-bottom behavior: Add a useEffect that scrolls to bottom on first render (when messages go from 0 to >0). Use a ref to track whether the initial scroll has happened:
      ```
      const initialScrollDone = useRef(false);
      useEffect(() => {
        if (messages.length > 0 && !initialScrollDone.current) {
          sentinelRef.current?.scrollIntoView({ behavior: 'instant' });
          initialScrollDone.current = true;
        }
      }, [messages.length]);
      ```
      Reset `initialScrollDone.current = false` when messages becomes empty (channel switch).

    **2. Update `DiscussionPanel.tsx` to show gateway status:**

    - Destructure `gatewayStatus` from `useMessages(channelId)` (in addition to existing destructured values)
    - In the header section, add a small status indicator next to the channel name:
      ```
      <div className="px-3 py-2 border-b border-gray-200 flex items-center justify-between">
        <h3 className="text-sm font-semibold text-gray-700">
          {channelName ? `#${channelName}` : 'Discussion'}
        </h3>
        {gatewayStatus === 'connected' && (
          <span className="w-2 h-2 rounded-full bg-green-500" title="Live" />
        )}
        {gatewayStatus === 'connecting' && (
          <span className="w-2 h-2 rounded-full bg-yellow-400 animate-pulse" title="Connecting..." />
        )}
        {gatewayStatus === 'reconnecting' && (
          <span className="w-2 h-2 rounded-full bg-yellow-400 animate-pulse" title="Reconnecting..." />
        )}
        {gatewayStatus === 'disconnected' && (
          <span className="w-2 h-2 rounded-full bg-gray-400" title="Disconnected" />
        )}
      </div>
      ```
      This is a minimal colored dot indicator -- green when live, pulsing yellow when connecting/reconnecting, gray when disconnected. The `title` attribute provides hover tooltip.

    **3. Run existing tests:**
    `cd lens-editor && npx vitest run`

    If tests fail due to the `gatewayStatus` field being missing from mock returns, update the test mocks to include `gatewayStatus: 'disconnected'` in the `useMessages` mock return value.

    AVOID: Do NOT auto-scroll on every message change (the old behavior). The useAutoScroll hook handles this correctly -- it only scrolls when `isAtBottom` is true.

    AVOID: Do NOT add complex status text like "Live - Connected to Discord". A colored dot is sufficient for Phase 2. Phase 4 (Connection Resilience) will add detailed status UI.
  </action>
  <verify>
    - `cd lens-editor && npx vitest run` -- all tests pass (update mocks if needed)
    - `cd lens-editor && npx tsc --noEmit` -- no type errors
    - MessageList.tsx uses `useAutoScroll` and renders `NewMessagesBar`
    - MessageList.tsx has sentinel div with ref for IntersectionObserver
    - DiscussionPanel.tsx shows gateway status indicator dot
    - No unconditional scrollIntoView on every messages change (old behavior removed)
  </verify>
  <done>MessageList uses auto-scroll with IntersectionObserver sentinel, renders NewMessagesBar when unseen messages exist, and DiscussionPanel shows live connection status.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify live streaming end-to-end</name>
  <what-built>
    Complete live streaming pipeline: Discord Gateway -> bridge sidecar -> SSE -> browser.
    Auto-scroll with IntersectionObserver sentinel and "new messages" indicator.
    Discord markdown rendering for all standard formatting.
    Gateway connection status indicator (colored dot in panel header).
  </what-built>
  <how-to-verify>
    Prerequisites: discord-bridge must be running with a valid DISCORD_BOT_TOKEN, and lens-editor dev server must be running.

    1. Start the discord-bridge: `cd discord-bridge && DISCORD_BOT_TOKEN=<token> npm run dev`
       - Confirm you see `[gateway] Connected as LucDevBot2#...` in the console
    2. Start lens-editor: `cd lens-editor && npm run dev:local`
    3. Open a document with a `discussion` frontmatter field in the browser
    4. Verify the panel header shows a GREEN dot (live connection status)
    5. In Discord, post a message in the linked channel. It should appear in the panel within ~2 seconds.
    6. Post a message with markdown formatting: `**bold** *italic* ~~strikethrough~~ \`code\` > quote`
       - Verify it renders with proper formatting (not raw markdown syntax)
    7. Post a code block message: triple backticks with some code
       - Verify it renders as a formatted code block
    8. Scroll UP in the message list (away from the bottom)
    9. Post another message in Discord
       - Verify the panel does NOT auto-scroll
       - Verify a "1 new message" indicator appears at the bottom of the panel
    10. Post 2 more messages in Discord
        - Verify the indicator updates to "3 new messages"
    11. Click the "new messages" indicator
        - Verify the panel scrolls to the bottom and the indicator disappears
    12. Verify the panel is now at the bottom and new messages auto-scroll again
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd lens-editor && npx tsc --noEmit`
2. All tests pass: `cd lens-editor && npx vitest run`
3. SSE connection established when panel loads (visible in browser Network tab as `events` request with `text/event-stream` type)
4. New messages from Discord appear in <2 seconds
5. Auto-scroll works when at bottom, pauses when scrolled up
6. "New messages" bar shows count and scrolls to bottom on click
7. Gateway status dot changes color based on connection state
8. No duplicate messages when SSE delivers a message already in REST response
9. Switching documents properly closes old SSE connection (no leaked connections in Network tab)
</verification>

<success_criteria>
- Messages posted in Discord appear in the panel within 2 seconds (INFRA-02, MSG-02)
- Auto-scroll to newest when at bottom; stops when scrolled up (MSG-06)
- "New messages" indicator appears when scrolled up with new messages (MSG-07)
- Gateway connection status visible in panel header
- No duplicate messages from SSE + REST overlap
- EventSource cleanup on component unmount / channel switch
</success_criteria>

<output>
After completion, create `.planning/phases/02-live-streaming/02-03-SUMMARY.md`
</output>
