---
phase: 02-live-streaming
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lens-editor/package.json
  - lens-editor/package-lock.json
  - lens-editor/src/components/DiscussionPanel/DiscordMarkdown.tsx
  - lens-editor/src/components/DiscussionPanel/MessageItem.tsx
autonomous: true

must_haves:
  truths:
    - "Messages with **bold**, *italic*, ~~strikethrough~~, `inline code`, code blocks, and > quotes render with proper formatting"
    - "Messages with spoiler tags render as hidden text that reveals on hover"
    - "URLs in messages render as clickable links"
    - "Plain text messages continue to render correctly"
    - "Empty message content renders nothing (no crash)"
  artifacts:
    - path: "lens-editor/src/components/DiscussionPanel/DiscordMarkdown.tsx"
      provides: "Discord markdown AST to React element renderer"
      exports: ["DiscordMarkdown"]
    - path: "lens-editor/src/components/DiscussionPanel/MessageItem.tsx"
      provides: "Message display using DiscordMarkdown instead of plain text"
      contains: "DiscordMarkdown"
  key_links:
    - from: "lens-editor/src/components/DiscussionPanel/MessageItem.tsx"
      to: "lens-editor/src/components/DiscussionPanel/DiscordMarkdown.tsx"
      via: "import and render DiscordMarkdown component with message.content"
      pattern: "<DiscordMarkdown"
    - from: "lens-editor/src/components/DiscussionPanel/DiscordMarkdown.tsx"
      to: "discord-markdown-parser"
      via: "parse() function call"
      pattern: "parse\\(content"
---

<objective>
Add Discord-flavored markdown rendering to message content in the DiscussionPanel.

Purpose: Messages in Discord use a custom markdown flavor (bold, italic, strikethrough, code blocks, quotes, spoilers, links). Rendering these correctly makes the panel match what users see in Discord, satisfying requirement MSG-05.

Output: DiscordMarkdown component that parses Discord markdown to AST and renders as React elements, integrated into MessageItem.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-live-streaming/02-RESEARCH.md

@lens-editor/src/components/DiscussionPanel/MessageItem.tsx
@lens-editor/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install discord-markdown-parser and create DiscordMarkdown component</name>
  <files>
    lens-editor/package.json
    lens-editor/package-lock.json
    lens-editor/src/components/DiscussionPanel/DiscordMarkdown.tsx
  </files>
  <action>
    1. Install discord-markdown-parser in the lens-editor directory:
       `cd lens-editor && npm install discord-markdown-parser`

    2. Create `lens-editor/src/components/DiscussionPanel/DiscordMarkdown.tsx`:
       - Import `parse` from `discord-markdown-parser`
       - Define an `ASTNode` interface for the parser output:
         ```
         interface ASTNode {
           type: string;
           content?: ASTNode[] | string;
           target?: string;
           lang?: string;
           id?: string;
         }
         ```
         NOTE: The library's TypeScript types may not be perfectly typed. Use this local interface and cast as needed. Inspect the actual types after install -- if the library exports usable types, prefer those over the local interface.

       - Implement `renderNodes(nodes: ASTNode[]): ReactNode[]` that maps each node through `renderNode`
       - Implement `renderNode(node: ASTNode, key: number): ReactNode` with a switch on `node.type`:
         - `'text'`: return `node.content as string`
         - `'strong'`: `<strong key={key}>{renderNodes(...)}</strong>`
         - `'em'`: `<em key={key}>{renderNodes(...)}</em>`
         - `'underline'`: `<u key={key}>{renderNodes(...)}</u>`
         - `'strikethrough'`: `<del key={key}>{renderNodes(...)}</del>`
         - `'inlineCode'`: `<code key={key} className="bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded text-sm font-mono">{node.content as string}</code>`
         - `'codeBlock'`: `<pre key={key} className="bg-gray-100 dark:bg-gray-800 p-2 rounded text-sm font-mono overflow-x-auto my-1"><code>{node.content as string}</code></pre>`
         - `'blockQuote'`: `<blockquote key={key} className="border-l-4 border-gray-300 pl-2 my-1">{renderNodes(...)}</blockquote>`
         - `'spoiler'`: `<span key={key} className="bg-gray-700 text-gray-700 hover:bg-transparent hover:text-inherit rounded px-0.5 cursor-pointer transition-colors">{renderNodes(...)}</span>`
         - `'url'` / `'autolink'`: `<a key={key} href={node.target} target="_blank" rel="noopener noreferrer" className="text-blue-600 hover:underline">{renderNodes(...)}</a>`
         - `'br'`: `<br key={key} />`
         - `'newline'`: `<br key={key} />` (some parsers use 'newline' instead of 'br')
         - Default fallback: if `node.content` is an array, render children in a `<span>`. If string, render as text. If nullish, render empty string.

       - Handle the edge case where a "node" is actually a raw string (not an object). The parser sometimes returns plain strings in the content array. Check `typeof node === 'string'` at the top of `renderNode`.

       - Export `DiscordMarkdown` component:
         ```
         interface DiscordMarkdownProps {
           content: string;
         }
         export function DiscordMarkdown({ content }: DiscordMarkdownProps) {
           if (!content) return null;
           const ast = parse(content, 'normal');
           return <>{renderNodes(ast as ASTNode[])}</>;
         }
         ```

       - Wrap the parse call in `useMemo` keyed on `content` to avoid re-parsing on every render:
         ```
         const rendered = useMemo(() => {
           if (!content) return null;
           const ast = parse(content, 'normal');
           return renderNodes(ast as ASTNode[]);
         }, [content]);
         return <>{rendered}</>;
         ```

    AVOID: Do NOT use `dangerouslySetInnerHTML`. The AST-based approach renders React elements safely. Do NOT try to handle Discord-specific features like user/role/channel mentions (@user, @role, #channel) or custom emoji in this phase -- those require additional API calls to resolve IDs to names. The renderer should gracefully fall back to showing the raw text for unhandled node types.
  </action>
  <verify>
    - `cd lens-editor && npx tsc --noEmit` passes
    - `discord-markdown-parser` appears in lens-editor/package.json dependencies
    - DiscordMarkdown.tsx exports the DiscordMarkdown component
  </verify>
  <done>DiscordMarkdown component exists, compiles, and handles all standard Discord markdown formatting types.</done>
</task>

<task type="auto">
  <name>Task 2: Replace plain text rendering with DiscordMarkdown in MessageItem</name>
  <files>
    lens-editor/src/components/DiscussionPanel/MessageItem.tsx
  </files>
  <action>
    Modify `lens-editor/src/components/DiscussionPanel/MessageItem.tsx`:

    1. Import the DiscordMarkdown component:
       `import { DiscordMarkdown } from './DiscordMarkdown';`

    2. Replace both instances of plain text content rendering. Currently there are two `<p>` tags that render `{content}` as plain text:
       - In the header section (showHeader=true): Replace `<p className="text-sm text-gray-700 whitespace-pre-wrap break-words">{content}</p>` with `<div className="text-sm text-gray-700 break-words"><DiscordMarkdown content={content} /></div>`
       - In the grouped section (showHeader=false): Same replacement pattern.

    NOTE: Change from `<p>` to `<div>` because DiscordMarkdown may render block-level elements (blockquote, pre) which are invalid inside `<p>`. Keep the `text-sm text-gray-700 break-words` classes on the wrapper div. Remove `whitespace-pre-wrap` since the markdown renderer handles line breaks via `<br>` tags.

    3. Keep the `{content && (...)}` guard on both locations -- DiscordMarkdown also handles empty content but the guard prevents rendering an empty wrapper div.

    4. Run existing tests to ensure nothing breaks:
       `cd lens-editor && npx vitest run`
       The existing DiscussionPanel tests check for message content text, which should still be present in the rendered output (DiscordMarkdown renders text nodes as plain text strings).
  </action>
  <verify>
    - `cd lens-editor && npx vitest run` -- all existing tests pass
    - `cd lens-editor && npx tsc --noEmit` -- no type errors
    - MessageItem.tsx imports and uses DiscordMarkdown component
    - No `<p>` tags wrapping message content (replaced with `<div>`)
  </verify>
  <done>MessageItem renders Discord-flavored markdown for all message content. Plain text messages still render correctly. Existing tests pass.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd lens-editor && npx tsc --noEmit`
2. All existing tests pass: `cd lens-editor && npx vitest run`
3. DiscordMarkdown handles: bold (**), italic (*), strikethrough (~~), inline code (`), code blocks (```), blockquotes (>), spoilers (||), links, line breaks
4. Empty/null content doesn't crash
5. Unrecognized node types fall back to text rendering
</verification>

<success_criteria>
- discord-markdown-parser installed in lens-editor
- DiscordMarkdown component parses Discord markdown AST and renders React elements
- MessageItem uses DiscordMarkdown instead of plain text for message content
- All formatting types listed in MSG-05 (bold, italic, code blocks, quotes, strikethrough) render correctly
- Existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-live-streaming/02-02-SUMMARY.md`
</output>
