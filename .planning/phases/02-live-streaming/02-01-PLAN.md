---
phase: 02-live-streaming
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - discord-bridge/package.json
  - discord-bridge/package-lock.json
  - discord-bridge/src/gateway.ts
  - discord-bridge/src/index.ts
  - discord-bridge/src/types.ts
autonomous: true

must_haves:
  truths:
    - "Discord Gateway connects and receives MESSAGE_CREATE events in real time"
    - "Browser can connect to SSE endpoint and receive streamed message events for a specific channel"
    - "SSE connection sends periodic heartbeats to keep the connection alive"
    - "Gateway status is queryable via REST endpoint"
  artifacts:
    - path: "discord-bridge/src/gateway.ts"
      provides: "Discord Gateway connection manager using discord.js Client"
      exports: ["startGateway", "getGatewayStatus", "gatewayEvents"]
    - path: "discord-bridge/src/index.ts"
      provides: "SSE endpoint and gateway status endpoint"
      contains: "streamSSE"
    - path: "discord-bridge/src/types.ts"
      provides: "DiscordUser.bot field for Gateway messages"
      contains: "bot"
  key_links:
    - from: "discord-bridge/src/gateway.ts"
      to: "discord.js Client"
      via: "client.login() with DISCORD_BOT_TOKEN"
      pattern: "client\\.login"
    - from: "discord-bridge/src/gateway.ts"
      to: "discord-bridge/src/index.ts"
      via: "gatewayEvents EventEmitter (channel-scoped)"
      pattern: "gatewayEvents\\.emit.*message:"
    - from: "discord-bridge/src/index.ts"
      to: "browser EventSource"
      via: "Hono streamSSE writing message events"
      pattern: "stream\\.writeSSE"
---

<objective>
Add Discord Gateway (WebSocket) connection and SSE streaming endpoint to the discord-bridge sidecar.

Purpose: Enable real-time message delivery from Discord to browser clients. The Gateway receives MESSAGE_CREATE events from Discord and the SSE endpoint forwards them to connected browsers, scoped by channel ID.

Output: Gateway connection manager module, SSE endpoint at `/api/channels/:channelId/events`, gateway status endpoint at `/api/gateway/status`.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-live-streaming/02-RESEARCH.md

@discord-bridge/src/index.ts
@discord-bridge/src/types.ts
@discord-bridge/src/discord-client.ts
@discord-bridge/package.json
@lens-editor/vite.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install discord.js and create Gateway connection manager</name>
  <files>
    discord-bridge/package.json
    discord-bridge/package-lock.json
    discord-bridge/src/gateway.ts
    discord-bridge/src/types.ts
  </files>
  <action>
    1. Install discord.js in the discord-bridge directory:
       `cd discord-bridge && npm install discord.js`

    2. Add `bot` field to `DiscordUser` in `discord-bridge/src/types.ts`:
       `bot?: boolean;`
       This field is needed because Gateway MESSAGE_CREATE events include the bot flag, and the frontend already uses it for APP badges (added in Phase 1).

    3. Create `discord-bridge/src/gateway.ts` implementing the Gateway connection manager:
       - Import `Client`, `GatewayIntentBits`, `Events` from `discord.js`
       - Import `EventEmitter` from `events`
       - Export a `gatewayEvents` EventEmitter instance for decoupling Gateway events from SSE delivery
       - Export `startGateway()` function:
         - Read `DISCORD_BOT_TOKEN` from env. If missing, log a warning and return (don't crash -- REST-only mode still works from Phase 1)
         - Create discord.js Client with intents: Guilds, GuildMessages, MessageContent
         - Listen for `Events.MessageCreate` -- on each message, emit a channel-scoped event `message:{channelId}` on `gatewayEvents` with a serializable payload:
           ```
           {
             id: message.id,
             content: message.content,
             author: {
               id: message.author.id,
               username: message.author.username,
               global_name: message.author.globalName,
               avatar: message.author.avatar,
               bot: message.author.bot,
             },
             timestamp: message.createdAt.toISOString(),
             type: message.type,
           }
           ```
         - Listen for `Events.ClientReady` -- log `[gateway] Connected as {tag}`
         - Listen for `Events.ShardReconnecting` -- log `[gateway] Reconnecting...`
         - Listen for `Events.ShardResume` -- log `[gateway] Resumed`
         - Call `client.login(token)`
       - Export `getGatewayStatus()` returning `'connected' | 'connecting' | 'disconnected'`:
         - No client: `'disconnected'`
         - Client exists and `client.isReady()`: `'connected'`
         - Otherwise: `'connecting'`

    IMPORTANT: The `gatewayEvents` EventEmitter should have `setMaxListeners(0)` to avoid Node.js warnings when many SSE clients connect (each subscribes a listener per channel).

    AVOID: Do NOT use `@discordjs/ws` standalone -- discord.js Client handles heartbeat, resume, reconnect, and rate limiting automatically. The weight difference is negligible for a sidecar process.
  </action>
  <verify>
    - `cd discord-bridge && npx tsc --noEmit` passes with no type errors
    - `discord-bridge/src/gateway.ts` exports startGateway, getGatewayStatus, gatewayEvents
    - `discord-bridge/src/types.ts` has `bot?: boolean` on DiscordUser
  </verify>
  <done>Gateway module compiles, exports the three public symbols, and discord.js is installed.</done>
</task>

<task type="auto">
  <name>Task 2: Add SSE endpoint and gateway status route, wire startup</name>
  <files>
    discord-bridge/src/index.ts
  </files>
  <action>
    Modify `discord-bridge/src/index.ts` to:

    1. Import `streamSSE` from `hono/streaming`
    2. Import `startGateway`, `getGatewayStatus`, `gatewayEvents` from `./gateway.js`

    3. Add SSE endpoint `GET /api/channels/:channelId/events`:
       - Use `streamSSE(c, async (stream) => { ... })`
       - On connection, send an initial `status` event with `{ gateway: getGatewayStatus() }`
       - Create a handler function that receives message data and calls `stream.writeSSE({ event: 'message', data: JSON.stringify(message), id: (message as { id: string }).id })`
       - Wrap the writeSSE call in try/catch -- if it throws, the client disconnected (handler will be cleaned up)
       - Register handler on `gatewayEvents` for `message:{channelId}`
       - Call `stream.onAbort(() => { gatewayEvents.off(\`message:${channelId}\`, handler); })` to clean up on disconnect
       - Keep the connection alive with a heartbeat loop: `while (true) { await stream.writeSSE({ event: 'heartbeat', data: '' }); await stream.sleep(30000); }` (30-second interval)

    4. Add REST endpoint `GET /api/gateway/status`:
       - Return `c.json({ status: getGatewayStatus() })`

    5. Call `startGateway()` BEFORE the `serve()` call at the bottom of the file. This starts the Gateway connection when the bridge sidecar boots. If DISCORD_BOT_TOKEN is missing, startGateway() logs a warning and returns -- the REST-only endpoints still work.

    IMPORTANT: Place the SSE route BEFORE the existing REST routes to avoid any route matching conflicts. Hono matches routes in definition order.

    AVOID: Do NOT add any buffering/compression middleware to the SSE route. SSE requires unbuffered streaming. The existing `logger()` middleware is fine. Do NOT implement manual reconnect logic in the SSE endpoint -- the browser's EventSource handles reconnection automatically.
  </action>
  <verify>
    - `cd discord-bridge && npx tsc --noEmit` passes
    - Start the bridge: `cd discord-bridge && DISCORD_BOT_TOKEN=test npm run dev` (will fail to connect to Discord but should not crash -- graceful handling of invalid token)
    - `curl -N http://localhost:8091/api/channels/test123/events` should return SSE headers (`Content-Type: text/event-stream`) and an initial `event: status` line
    - `curl http://localhost:8091/api/gateway/status` should return `{"status":"connecting"}` or `{"status":"disconnected"}`
    - Existing REST endpoints still work: `curl http://localhost:8091/health` returns `{"status":"ok"}`
  </verify>
  <done>SSE endpoint streams events for a channel, gateway status is queryable, bridge starts Gateway on boot, and all existing REST endpoints continue to work.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `cd discord-bridge && npx tsc --noEmit`
2. Bridge starts without crashing (even without valid bot token)
3. SSE endpoint returns `text/event-stream` content type
4. Gateway status endpoint returns JSON with status field
5. Existing `/health` and `/api/channels/:id/messages` endpoints unaffected
</verification>

<success_criteria>
- discord.js installed in discord-bridge
- Gateway module connects to Discord and emits channel-scoped events via EventEmitter
- SSE endpoint at `/api/channels/:channelId/events` streams message events to connected clients
- Gateway status queryable at `/api/gateway/status`
- Bridge degrades gracefully when DISCORD_BOT_TOKEN is missing (REST still works, Gateway disabled)
</success_criteria>

<output>
After completion, create `.planning/phases/02-live-streaming/02-01-SUMMARY.md`
</output>
