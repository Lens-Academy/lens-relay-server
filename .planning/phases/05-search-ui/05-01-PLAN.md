---
phase: 05-search-ui
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lens-editor/src/lib/relay-api.ts
  - lens-editor/src/hooks/useSearch.ts
  - lens-editor/src/hooks/useSearch.test.ts
  - lens-editor/src/components/Sidebar/SearchPanel.tsx
  - lens-editor/src/components/Sidebar/SearchPanel.test.tsx
autonomous: true

must_haves:
  truths:
    - "searchDocuments() fetches from /search endpoint with query and limit params"
    - "useSearch debounces queries by 300ms before fetching"
    - "useSearch returns results, loading, and error states"
    - "useSearch clears results when query is empty"
    - "SearchPanel renders document title, folder, and snippet for each result"
    - "SearchPanel calls onNavigate with compound doc ID on click"
    - "SearchPanel shows loading, error, and empty states"
  artifacts:
    - path: "lens-editor/src/lib/relay-api.ts"
      provides: "searchDocuments function and SearchResult/SearchResponse types"
      exports: ["searchDocuments", "SearchResult", "SearchResponse"]
    - path: "lens-editor/src/hooks/useSearch.ts"
      provides: "Debounced search hook"
      exports: ["useSearch"]
    - path: "lens-editor/src/hooks/useSearch.test.ts"
      provides: "Tests for debounce, fetch, error, and empty query behavior"
      contains: "describe.*useSearch"
    - path: "lens-editor/src/components/Sidebar/SearchPanel.tsx"
      provides: "Search results list component"
      exports: ["SearchPanel"]
    - path: "lens-editor/src/components/Sidebar/SearchPanel.test.tsx"
      provides: "Tests for rendering, click navigation, states"
      contains: "describe.*SearchPanel"
  key_links:
    - from: "lens-editor/src/hooks/useSearch.ts"
      to: "lens-editor/src/lib/relay-api.ts"
      via: "import searchDocuments"
      pattern: "import.*searchDocuments.*relay-api"
    - from: "lens-editor/src/components/Sidebar/SearchPanel.tsx"
      to: "lens-editor/src/lib/relay-api.ts"
      via: "import SearchResult type"
      pattern: "import.*SearchResult.*relay-api"
---

<objective>
Build the search API client, debounced search hook, and search results panel component -- the three independent building blocks for the Search UI.

Purpose: These are the core pieces that Plan 02 will wire into the sidebar. Building them first (with tests) ensures each piece works correctly before integration.
Output: Tested `searchDocuments()` function, `useSearch` hook, and `SearchPanel` component ready for sidebar integration.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-search-ui/05-RESEARCH.md

@lens-editor/src/lib/relay-api.ts
@lens-editor/src/hooks/index.ts
@lens-editor/src/components/Sidebar/SearchPanel.tsx (will be created)
@lens-editor/src/components/BacklinksPanel/BacklinksPanel.tsx (navigation pattern reference)
@lens-editor/src/App.tsx (RELAY_ID export)
</context>

<tasks>

<task type="auto">
  <name>Task 1: searchDocuments API function + useSearch hook (TDD)</name>
  <files>
    lens-editor/src/lib/relay-api.ts
    lens-editor/src/hooks/useSearch.ts
    lens-editor/src/hooks/useSearch.test.ts
  </files>
  <action>
**Step 1: Add searchDocuments to relay-api.ts**

Add these types and function to the EXISTING `relay-api.ts` file (append after the existing exports):

```typescript
export interface SearchResult {
  doc_id: string;   // UUID (no RELAY_ID prefix)
  title: string;
  folder: string;
  snippet: string;  // HTML with <mark> tags
  score: number;
}

export interface SearchResponse {
  results: SearchResult[];
  total_hits: number;
  query: string;
}

export async function searchDocuments(
  query: string,
  limit: number = 20,
  signal?: AbortSignal
): Promise<SearchResponse> {
  const params = new URLSearchParams({ q: query, limit: String(limit) });
  const response = await fetch(`${API_BASE}/search?${params}`, { signal });
  if (!response.ok) {
    throw new Error(`Search failed: ${response.status}`);
  }
  return response.json();
}
```

The `API_BASE` constant already exists in relay-api.ts (line 16). The `signal` parameter enables AbortController cancellation from the hook.

**Step 2: Write failing tests for useSearch hook**

Create `lens-editor/src/hooks/useSearch.test.ts`:
- Mock `searchDocuments` from `../lib/relay-api` using `vi.mock`
- Test: empty query returns empty results and does NOT call searchDocuments
- Test: query shorter than 2 chars returns empty results and does NOT call searchDocuments (minimum query length)
- Test: valid query (2+ chars) calls searchDocuments after debounce delay
- Test: loading is true while request is in flight, false after
- Test: error state is set when searchDocuments throws
- Test: changing query aborts previous request (use vi.advanceTimersByTime with fake timers)
- Use `renderHook` from `@testing-library/react` and `act` for state updates
- Use `vi.useFakeTimers()` to control debounce timing

Run tests -- they MUST fail (RED phase). Commit: `test(05-01): add failing tests for useSearch hook`

**Step 3: Implement useSearch hook**

Create `lens-editor/src/hooks/useSearch.ts`:

```typescript
import { useState, useEffect, useRef } from 'react';
import { searchDocuments, type SearchResult } from '../lib/relay-api';

interface UseSearchReturn {
  results: SearchResult[];
  loading: boolean;
  error: string | null;
}

export function useSearch(query: string, debounceMs = 300): UseSearchReturn {
  const [results, setResults] = useState<SearchResult[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const abortRef = useRef<AbortController | null>(null);

  useEffect(() => {
    const trimmed = query.trim();

    // Minimum 2 characters to avoid noise
    if (trimmed.length < 2) {
      setResults([]);
      setLoading(false);
      setError(null);
      return;
    }

    setLoading(true);

    const timer = setTimeout(async () => {
      abortRef.current?.abort();
      const controller = new AbortController();
      abortRef.current = controller;

      try {
        const response = await searchDocuments(trimmed, 20, controller.signal);
        if (!controller.signal.aborted) {
          setResults(response.results);
          setError(null);
        }
      } catch (err) {
        if (!controller.signal.aborted) {
          const message = err instanceof Error ? err.message : 'Search failed';
          // Handle 503 gracefully (index initializing)
          if (message.includes('503')) {
            setError('Search is initializing...');
          } else {
            setError(message);
          }
          setResults([]);
        }
      } finally {
        if (!controller.signal.aborted) {
          setLoading(false);
        }
      }
    }, debounceMs);

    return () => {
      clearTimeout(timer);
      abortRef.current?.abort();
    };
  }, [query, debounceMs]);

  return { results, loading, error };
}
```

Run tests -- they MUST pass (GREEN phase). Commit: `feat(05-01): implement useSearch hook with debounce and abort`

**Step 4: Refactor if needed.** If tests pass and code is clean, skip. Otherwise refactor and re-run tests.
  </action>
  <verify>
    cd lens-editor && npx vitest run src/hooks/useSearch.test.ts
  </verify>
  <done>
    All useSearch tests pass. searchDocuments is exported from relay-api.ts. useSearch debounces queries, handles loading/error/empty states, and aborts stale requests.
  </done>
</task>

<task type="auto">
  <name>Task 2: SearchPanel component with tests</name>
  <files>
    lens-editor/src/components/Sidebar/SearchPanel.tsx
    lens-editor/src/components/Sidebar/SearchPanel.test.tsx
  </files>
  <action>
**Step 1: Write tests for SearchPanel**

Create `lens-editor/src/components/Sidebar/SearchPanel.test.tsx`:
- Use `@vitest-environment happy-dom` pragma
- Test: renders result titles and folder labels
- Test: renders snippet HTML (with `<mark>` tags) using dangerouslySetInnerHTML
- Test: calls onNavigate with `RELAY_ID-doc_id` when clicking a result
- Test: shows "Searching..." when loading=true
- Test: shows error message when error is set
- Test: shows "No results found" when query is non-empty but results are empty
- Test: renders nothing (or empty state text) when query is empty and results are empty
- Follow the test pattern from `Sidebar.test.tsx` -- render with props, assert with screen queries

Run tests -- MUST fail (RED). Commit: `test(05-01): add failing tests for SearchPanel`

**Step 2: Implement SearchPanel**

Create `lens-editor/src/components/Sidebar/SearchPanel.tsx`:

```typescript
import { RELAY_ID } from '../../App';
import type { SearchResult } from '../../lib/relay-api';

interface SearchPanelProps {
  results: SearchResult[];
  loading: boolean;
  error: string | null;
  query: string;
  onNavigate: (docId: string) => void;
}

export function SearchPanel({ results, loading, error, query, onNavigate }: SearchPanelProps) {
  if (loading) {
    return <div className="p-4 text-sm text-gray-500">Searching...</div>;
  }
  if (error) {
    return <div className="p-4 text-sm text-red-500">{error}</div>;
  }
  if (query && results.length === 0) {
    return <div className="p-4 text-sm text-gray-500">No results found</div>;
  }

  return (
    <ul className="divide-y divide-gray-100">
      {results.map((result) => (
        <li key={result.doc_id}>
          <button
            onClick={() => onNavigate(`${RELAY_ID}-${result.doc_id}`)}
            className="w-full text-left px-3 py-2 hover:bg-gray-50 transition-colors"
          >
            <div className="text-sm font-medium text-gray-900 truncate">
              {result.title}
            </div>
            {result.folder && (
              <span className="text-xs text-gray-400">{result.folder}</span>
            )}
            <div
              className="text-xs text-gray-600 mt-0.5 line-clamp-2 [&_mark]:bg-yellow-200 [&_mark]:rounded-sm"
              dangerouslySetInnerHTML={{ __html: result.snippet }}
            />
          </button>
        </li>
      ))}
    </ul>
  );
}
```

Note: The `[&_mark]:bg-yellow-200` Tailwind arbitrary selector styles `<mark>` tags inside the snippet div. This avoids needing a separate CSS file.

Run tests -- MUST pass (GREEN). Commit: `feat(05-01): implement SearchPanel component`
  </action>
  <verify>
    cd lens-editor && npx vitest run src/components/Sidebar/SearchPanel.test.tsx
  </verify>
  <done>
    All SearchPanel tests pass. Component renders results with titles, folders, snippets (with mark highlights), handles loading/error/empty states, and calls onNavigate with correct compound doc IDs.
  </done>
</task>

</tasks>

<verification>
```bash
cd lens-editor && npx vitest run src/hooks/useSearch.test.ts src/components/Sidebar/SearchPanel.test.tsx
```
All tests pass. No regressions in existing tests:
```bash
cd lens-editor && npx vitest run
```
</verification>

<success_criteria>
- searchDocuments() exported from relay-api.ts, calls GET /search with query params
- useSearch hook debounces (300ms default), returns {results, loading, error}
- useSearch ignores queries shorter than 2 characters
- useSearch aborts stale requests via AbortController
- SearchPanel renders titles, folders, snippets with mark highlighting
- SearchPanel calls onNavigate with compound doc ID (RELAY_ID-doc_uuid)
- SearchPanel handles loading, error, and empty states
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-search-ui/05-01-SUMMARY.md`
</output>
