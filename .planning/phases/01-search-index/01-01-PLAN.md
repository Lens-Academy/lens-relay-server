---
phase: 01-search-index
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/y-sweet-core/Cargo.toml
  - crates/y-sweet-core/src/lib.rs
  - crates/y-sweet-core/src/search_index.rs
autonomous: true

must_haves:
  truths:
    - "A search query returns documents whose title or body contains the query terms"
    - "Search results include BM25 relevance scores with title matches ranked higher than body-only matches"
    - "Search results include text snippets with <mark> tags around matched terms"
    - "Updating a document in the index replaces the old version (no duplicates)"
    - "Removing a document from the index means it no longer appears in search results"
    - "An empty or whitespace-only query returns zero results without errors"
  artifacts:
    - path: "crates/y-sweet-core/src/search_index.rs"
      provides: "SearchIndex struct with full-text search capabilities"
      exports: ["SearchIndex", "SearchResult"]
      min_lines: 150
    - path: "crates/y-sweet-core/Cargo.toml"
      provides: "tantivy dependency"
      contains: "tantivy"
  key_links:
    - from: "SearchIndex::add_document"
      to: "tantivy IndexWriter"
      via: "delete_term + add_document + commit"
      pattern: "writer.*delete_term.*add_document.*commit"
    - from: "SearchIndex::search"
      to: "tantivy QueryParser + SnippetGenerator"
      via: "parse_query_lenient + TopDocs + snippet_from_doc"
      pattern: "parse_query_lenient.*TopDocs.*snippet"
---

<objective>
Build the SearchIndex core module with tantivy: schema definition, document add/update/remove, BM25-ranked search with snippet generation, and comprehensive tests.

Purpose: This is the foundation for all search functionality. The MCP server, HTTP API, and lens-editor UI all depend on this module to find and rank documents.
Output: A tested `search_index.rs` module in y-sweet-core that provides `SearchIndex` and `SearchResult` types.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-search-index/01-CONTEXT.md
@.planning/phases/01-search-index/01-RESEARCH.md
@crates/y-sweet-core/Cargo.toml
@crates/y-sweet-core/src/lib.rs
@crates/y-sweet-core/src/link_indexer.rs (reference pattern for DashMap access, Y.Doc content extraction, folder doc scanning)
</context>

<feature>
  <name>SearchIndex core module</name>
  <files>
    crates/y-sweet-core/Cargo.toml
    crates/y-sweet-core/src/lib.rs
    crates/y-sweet-core/src/search_index.rs
  </files>
  <behavior>
    The SearchIndex struct wraps a tantivy Index with MmapDirectory, providing:

    1. **Schema**: Four fields:
       - `doc_id` (STRING | STORED) — unique document identifier, used for delete_term
       - `title` (TEXT | STORED) — document name, boosted 2x at query time
       - `body` (TEXT | STORED) — full markdown content (STORED required for snippet generation)
       - `folder` (STORED only) — "Lens" or "Lens Edu", not searchable in v1

    2. **Construction**: `SearchIndex::new(path: &Path) -> Result<Self>`
       - Creates MmapDirectory at the given path
       - Opens or creates the tantivy index
       - Creates IndexWriter with 15MB budget
       - Creates IndexReader with OnCommitWithDelay reload policy
       - Builds QueryParser with conjunction_by_default (AND semantics) and title boost 2.0

    3. **Indexing**: `add_document(doc_id, title, body, folder) -> Result<()>`
       - Deletes existing document with same doc_id (delete_term on doc_id field)
       - Adds new tantivy document with all four fields
       - Commits the writer
       - This is idempotent — calling it twice with same doc_id just replaces

    4. **Removal**: `remove_document(doc_id) -> Result<()>`
       - Deletes document by doc_id term
       - Commits the writer

    5. **Search**: `search(query: &str, limit: usize) -> Result<Vec<SearchResult>>`
       - Returns empty vec for empty/whitespace query
       - Parses query with parse_query_lenient (tolerates syntax errors)
       - Searches with TopDocs collector limited to `limit`
       - Generates snippets with SnippetGenerator (max 150 chars)
       - Renders snippets with custom <mark> tags (not default <b>)
       - Returns SearchResult { doc_id, title, folder, snippet, score }

    Test cases (RED phase):
    - Empty index returns empty results
    - Add one document, search by title term -> finds it with score > 0
    - Add one document, search by body term -> finds it
    - Title match scores higher than body-only match (add two docs, one with term in title, one only in body)
    - Search returns snippet with <mark> tags around matched term
    - Snippet does NOT contain <b> tags (custom rendering)
    - Update document (add_document with same doc_id, different body) -> search reflects new content
    - Remove document -> search no longer finds it
    - Empty query returns empty results
    - Query with only whitespace returns empty results
    - Search with limit=1 returns at most 1 result
    - Phrase search with quotes works: "exact phrase"
    - AND semantics: query "foo bar" only matches docs containing both terms
    - Lenient parsing: malformed query like `foo AND` does not error
  </behavior>
  <implementation>
    1. Add `tantivy = "0.25"` to crates/y-sweet-core/Cargo.toml [dependencies]
    2. Add `pub mod search_index;` to crates/y-sweet-core/src/lib.rs
    3. Create crates/y-sweet-core/src/search_index.rs with:
       - `SearchResult` struct (with Serialize derive for later JSON responses)
       - `SearchIndex` struct with fields: index, schema, title_field, body_field, doc_id_field, folder_field, writer (Mutex<IndexWriter>), reader (IndexReader), query_parser (stored for reuse)
       - `SearchIndex::new(path)` constructor
       - `SearchIndex::add_document(doc_id, title, body, folder)` method
       - `SearchIndex::remove_document(doc_id)` method
       - `SearchIndex::search(query, limit)` method
       - Private `render_snippet_with_mark(snippet)` helper
       - `#[cfg(test)] mod tests` with all test cases

    Key tantivy API details (from research):
    - Use `tantivy::TantivyDocument` (not `Document`) for the concrete type in 0.25
    - Use `searcher.doc::<TantivyDocument>(doc_address)?` with explicit type parameter
    - Use `tantivy::Term::from_field_text(field, value)` for delete_term
    - Use `tantivy::doc!()` macro for document creation
    - Use `tantivy::schema::{TEXT, STORED, STRING}` for field options
    - Use `IndexReader::builder().reload_policy(ReloadPolicy::OnCommitWithDelay).try_open()?`
    - SnippetGenerator: `create(&searcher, &*query, body_field)?`, then `set_max_num_chars(150)`
    - Custom snippet rendering: iterate `snippet.highlighted()` ranges over `snippet.fragment()`

    For tests, use `tantivy::directory::RamDirectory` (not MmapDirectory) to avoid filesystem side effects. Create a `SearchIndex::new_in_memory()` constructor for tests (or a `new_with_directory` that accepts any Directory).

    Important: The IndexWriter Mutex and all tantivy operations are synchronous. This module does NOT deal with async — the async boundary (spawn_blocking) will be handled in Plan 02 when wiring into the server.
  </implementation>
</feature>

<verification>
```bash
# Run search_index tests
CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo test --manifest-path=crates/y-sweet-core/Cargo.toml search_index -- --nocapture

# Verify all existing tests still pass
CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo test --manifest-path=crates/y-sweet-core/Cargo.toml -- --nocapture
```
</verification>

<success_criteria>
All search_index tests pass. All existing y-sweet-core tests still pass. The SearchIndex struct can be constructed, documents can be added/removed, and search returns BM25-ranked results with <mark>-tagged snippets.
</success_criteria>

<output>
After completion, create `.planning/phases/01-search-index/01-01-SUMMARY.md`
</output>
