---
phase: 04-mcp-search-edit-tools
plan: 02
type: tdd
wave: 2
depends_on: ["04-01"]
files_modified:
  - crates/relay/src/mcp/tools/edit.rs
  - crates/relay/src/mcp/tools/mod.rs
autonomous: true

must_haves:
  truths:
    - "An AI assistant can call edit with file_path/old_string/new_string and the document is modified with CriticMarkup wrapping"
    - "The edit replaces old_string with {--old_string--}{++new_string++} in the Y.Doc"
    - "Editing a document the session has NOT read is rejected with a clear error message"
    - "Editing with an old_string not found in the document returns an error"
    - "Editing with an old_string that appears multiple times returns an error asking for more context"
    - "CriticMarkup suggestions are visible in the document content after edit"
  artifacts:
    - path: "crates/relay/src/mcp/tools/edit.rs"
      provides: "CriticMarkup-wrapped edit tool"
      exports: ["execute"]
    - path: "crates/relay/src/mcp/tools/mod.rs"
      provides: "edit in dispatch_tool and tool_definitions"
      contains: "\"edit\""
  key_links:
    - from: "crates/relay/src/mcp/tools/edit.rs"
      to: "crates/relay/src/mcp/session.rs"
      via: "edit checks session.read_docs before allowing modification"
      pattern: "read_docs\\.contains"
    - from: "crates/relay/src/mcp/tools/edit.rs"
      to: "Y.Doc TextRef"
      via: "remove_range + insert for CriticMarkup wrapping"
      pattern: "remove_range.*insert"
    - from: "crates/relay/src/mcp/tools/mod.rs"
      to: "crates/relay/src/mcp/tools/edit.rs"
      via: "dispatch_tool routes edit calls with session_id"
      pattern: "edit::execute.*session_id"
---

<objective>
Implement the edit MCP tool with CriticMarkup wrapping and read-before-edit enforcement.

Purpose: This gives AI assistants the ability to propose document edits as reviewable CriticMarkup suggestions. The `{--old--}{++new++}` format lets human collaborators see exactly what the AI wants to change and accept/reject each suggestion in Obsidian or lens-editor.

Output: Working edit tool that wraps changes in CriticMarkup, enforces read-before-edit, handles error cases (not found, not unique, unread doc). All verified by TDD.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-mcp-search-edit-tools/04-RESEARCH.md
@.planning/phases/04-mcp-search-edit-tools/04-01-SUMMARY.md
@crates/relay/src/mcp/tools/mod.rs
@crates/relay/src/mcp/tools/read.rs
@crates/relay/src/mcp/session.rs
@crates/relay/src/mcp/router.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Edit tool with CriticMarkup wrapping (TDD)</name>
  <files>
    crates/relay/src/mcp/tools/edit.rs
    crates/relay/src/mcp/tools/mod.rs
  </files>
  <action>

**RED phase -- Write failing tests first:**

Create `crates/relay/src/mcp/tools/edit.rs` with tests only (no implementation). Tests to write:

Use the same test helper pattern from Plan 01 (create_test_doc, Server::new_for_test). For edit tests, also need to set up a session with a read_doc recorded (simulating a prior read):

```rust
fn setup_session_with_read(server: &Arc<Server>, doc_id: &str) -> String {
    let sid = server.mcp_sessions.create_session("2025-03-26".into(), None);
    server.mcp_sessions.mark_initialized(&sid);
    if let Some(mut session) = server.mcp_sessions.get_session_mut(&sid) {
        session.read_docs.insert(doc_id.to_string());
    }
    sid
}
```

Tests:

1. `edit_basic_replacement` -- old_string="hello" new_string="world" in a document containing "say hello to all". After edit, document content contains `say {--hello--}{++world++} to all`. Verify the Y.Doc text actually changed (read it back).

2. `edit_read_before_edit_enforced` -- Call edit WITHOUT having the doc_id in read_docs. Expect error containing "must read this document before editing" (or similar).

3. `edit_old_string_not_found` -- old_string="nonexistent" not in document. Expect error containing "not found".

4. `edit_old_string_not_unique` -- Document contains "the cat sat on the cat". old_string="the cat". Expect error containing "not unique" and mentioning the occurrence count (2).

5. `edit_document_not_found` -- file_path="Nonexistent/Doc.md" that doesn't resolve. Expect error containing "Document not found".

6. `edit_missing_parameters` -- Call with missing old_string or new_string. Expect error about missing required parameter.

7. `edit_preserves_surrounding_content` -- Document is "line 1\nline 2\nline 3". Edit old_string="line 2" new_string="modified line 2". Verify full content is "line 1\n{--line 2--}{++modified line 2++}\nline 3".

8. `edit_multiline_old_string` -- old_string spans multiple lines: "line 2\nline 3". Verify CriticMarkup wraps the entire multiline string.

9. `edit_empty_new_string` -- old_string="delete me" new_string="". This is a deletion. Verify content has `{--delete me--}{++++}` (empty insertion is valid CriticMarkup).

10. `edit_success_message` -- Verify the Ok return string mentions the file_path and CriticMarkup.

11. `edit_toctou_protection` -- This tests the re-verify step. Create a doc, read it (to populate read_docs), then directly modify the Y.Doc content to shift offsets before calling edit. The edit should detect the mismatch and return an error about "Document changed since last read" (or re-search and succeed if old_string still exists at a different offset).

Note: For test 11 (TOCTOU), the simplest approach is: after the initial content read inside execute(), if the content has changed, the re-verify check in the write transaction will catch it. To test this, we need to simulate the race. Since our edit tool does re-verify in the write txn, the test just needs to verify that if old_string is NOT at the expected byte offset when re-checked, the tool errors. This is hard to test via a race condition, so instead test it structurally: verify the re-verify code path exists by checking that the implementation re-reads content in the write transaction.

Simpler approach for test 11: Just verify that after a successful edit, reading the document back shows the CriticMarkup. This implicitly proves the write transaction worked. Skip the race condition test for v1 -- the re-verify code is simple enough to verify by code review.

Add `pub mod edit;` to `tools/mod.rs`. Add edit to `tool_definitions()` with schema: `name: "edit"`, `description: "Edit a document by replacing old_string with new_string. The change is wrapped in CriticMarkup ({--old--}{++new++}) for human review. You must read the document first."`, required: ["file_path", "old_string", "new_string"], properties: file_path (string), old_string (string), new_string (string). No replace_all for v1.

Add `"edit"` case to dispatch_tool: `edit::execute(server, session_id, arguments)`.

Commit RED: `test(04-02): add failing tests for edit tool with CriticMarkup wrapping`

**GREEN phase -- Implement to pass all tests:**

Implement `edit::execute(server, session_id, arguments) -> Result<String, String>`:

1. **Parse parameters:** Extract file_path (required), old_string (required), new_string (required) from arguments. Return error for missing params.

2. **Resolve document:** Use `server.doc_resolver().resolve_path(file_path)` to get DocInfo. Return "Document not found: {file_path}" if None.

3. **Check read-before-edit:** Get session via `server.mcp_sessions.get_session(session_id)`. Check if `session.read_docs.contains(&doc_info.doc_id)`. If not, return error: `"You must read this document before editing it. Call the read tool with file_path: \"{file_path}\" first."`. Drop the session guard immediately after the check.

4. **Read content and find old_string:**
   ```rust
   let content = {
       let doc_ref = server.docs().get(&doc_info.doc_id)
           .ok_or_else(|| format!("Error: Document data not loaded: {}", file_path))?;
       let awareness = doc_ref.awareness();
       let guard = awareness.read().unwrap();
       let txn = guard.doc.transact();
       match txn.get_text("contents") {
           Some(text) => text.get_string(&txn),
           None => return Err("Document has no content".to_string()),
       }
   };
   ```

5. **Find old_string and check uniqueness:**
   ```rust
   let matches: Vec<usize> = content.match_indices(old_string)
       .map(|(idx, _)| idx)
       .collect();
   if matches.is_empty() {
       return Err(format!(
           "Error: old_string not found in {}. Make sure it matches exactly.",
           file_path
       ));
   }
   if matches.len() > 1 {
       return Err(format!(
           "Error: old_string is not unique in {} ({} occurrences found). Include more surrounding context to make it unique.",
           file_path, matches.len()
       ));
   }
   ```

6. **Build CriticMarkup replacement:**
   ```rust
   let byte_offset = matches[0] as u32;
   let old_len = old_string.len() as u32;
   let replacement = format!("{{--{}--}}{{++{}++}}", old_string, new_string);
   ```

7. **Apply edit in write transaction with TOCTOU re-verify:**
   ```rust
   {
       let doc_ref = server.docs().get(&doc_info.doc_id)
           .ok_or_else(|| format!("Error: Document data not loaded: {}", file_path))?;
       let awareness = doc_ref.awareness();
       let guard = awareness.read().unwrap();
       let mut txn = guard.doc.transact_mut();
       let text = txn.get_or_insert_text("contents");

       // Re-verify: check old_string still at expected offset
       let current_content = text.get_string(&txn);
       let actual_slice = current_content.get(byte_offset as usize..(byte_offset + old_len) as usize);
       if actual_slice != Some(old_string) {
           return Err("Document changed since last read. Please re-read and try again.".to_string());
       }

       text.remove_range(&mut txn, byte_offset, old_len);
       text.insert(&mut txn, byte_offset, &replacement);
   }
   ```

8. **Return success:**
   ```rust
   Ok(format!(
       "Edited {}: replaced {} characters with CriticMarkup suggestion for human review.",
       file_path, old_string.len()
   ))
   ```

Update the `tools_list_returns_four_tools` test in router.rs to expect 5 tools (or if Plan 01 already made it 4, update to 5). Rename appropriately.

Commit GREEN: `feat(04-02): implement edit tool with CriticMarkup wrapping and read-before-edit enforcement`

**REFACTOR phase (if needed):** Only if obvious cleanup exists. Run all tests to confirm passing.

  </action>
  <verify>
    Run: `CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo test --manifest-path=/home/penguin/code/lens-relay/ws3/crates/relay/Cargo.toml -- --nocapture 2>&1 | tail -30`
    All tests pass including new edit tests.
    Existing tests (router, read, session, glob, get_links, grep from Plan 01) still pass.
  </verify>
  <done>
    - edit tool wraps old_string/new_string in CriticMarkup {--old--}{++new++}
    - Read-before-edit enforced: unread documents cannot be edited
    - Error messages match Claude Code Edit patterns (not found, not unique)
    - TOCTOU protection via re-verify in write transaction
    - All existing + new tests pass
    - tool_definitions returns 5 tools (read, glob, get_links, grep, edit)
  </done>
</task>

</tasks>

<verification>
- `cargo test` passes all tests (existing + Plans 01 and 02)
- `cargo build` compiles cleanly
- tool_definitions() returns 5 tools total
- Edit tool CriticMarkup format is exactly `{--old--}{++new++}` (not substitution syntax)
- Read-before-edit gate rejects edits on unread documents
- Edit error messages are helpful and specific
</verification>

<success_criteria>
- AI assistants can call edit with old_string/new_string and changes appear as CriticMarkup
- Unread documents cannot be edited (clear error message guides AI to read first)
- Edge cases handled: not found, not unique, missing params, empty new_string
- CriticMarkup visible in document content for human review
</success_criteria>

<output>
After completion, create `.planning/phases/04-mcp-search-edit-tools/04-02-SUMMARY.md`
</output>
