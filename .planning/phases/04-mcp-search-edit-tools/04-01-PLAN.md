---
phase: 04-mcp-search-edit-tools
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/relay/Cargo.toml
  - crates/relay/src/mcp/session.rs
  - crates/relay/src/mcp/router.rs
  - crates/relay/src/mcp/tools/mod.rs
  - crates/relay/src/mcp/tools/read.rs
  - crates/relay/src/mcp/tools/grep.rs
autonomous: true

must_haves:
  truths:
    - "An AI assistant can call grep with a regex pattern and receive matching lines with file paths and line numbers"
    - "Grep results include context lines before/after matches when requested"
    - "Grep supports files_with_matches, content, and count output modes"
    - "The read tool records which documents a session has read"
    - "Session ID is threaded through dispatch_tool to all session-aware tools"
  artifacts:
    - path: "crates/relay/src/mcp/tools/grep.rs"
      provides: "Regex content search across Y.Docs"
      exports: ["execute"]
    - path: "crates/relay/src/mcp/session.rs"
      provides: "McpSession with read_docs HashSet"
      contains: "read_docs"
    - path: "crates/relay/src/mcp/tools/mod.rs"
      provides: "dispatch_tool with session_id parameter, grep in tool_definitions"
      contains: "grep"
  key_links:
    - from: "crates/relay/src/mcp/router.rs"
      to: "crates/relay/src/mcp/tools/mod.rs"
      via: "handle_tools_call passes session_id to dispatch_tool"
      pattern: "dispatch_tool.*session_id"
    - from: "crates/relay/src/mcp/tools/read.rs"
      to: "crates/relay/src/mcp/session.rs"
      via: "read tool inserts doc_id into session.read_docs"
      pattern: "read_docs\\.insert"
    - from: "crates/relay/src/mcp/tools/grep.rs"
      to: "crates/relay/src/mcp/tools/mod.rs"
      via: "dispatch_tool routes grep calls"
      pattern: "\"grep\""
---

<objective>
Implement the grep MCP tool (regex content search across Y.Docs), thread session_id through the tool dispatch chain, and add read-tracking to McpSession/read tool.

Purpose: This provides the AI assistant's primary search capability (regex pattern matching with line numbers and context, mirroring Claude Code's Grep) and establishes the session_id infrastructure that the edit tool (Plan 02) requires for read-before-edit enforcement.

Output: Working grep tool, session_id threaded through dispatch, read tool records reads in session state. All verified by TDD.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-mcp-search-edit-tools/04-RESEARCH.md
@crates/relay/src/mcp/tools/mod.rs
@crates/relay/src/mcp/tools/read.rs
@crates/relay/src/mcp/router.rs
@crates/relay/src/mcp/session.rs
@crates/relay/Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Infrastructure changes + grep tool (TDD)</name>
  <files>
    crates/relay/Cargo.toml
    crates/relay/src/mcp/session.rs
    crates/relay/src/mcp/router.rs
    crates/relay/src/mcp/tools/mod.rs
    crates/relay/src/mcp/tools/read.rs
    crates/relay/src/mcp/tools/grep.rs
  </files>
  <action>

**RED phase -- Write failing tests first:**

Create `crates/relay/src/mcp/tools/grep.rs` with tests only (no implementation). Tests to write:

1. `grep_basic_match` -- Search for a literal string, expect `path:line_num:line_content` format in content mode
2. `grep_case_insensitive` -- Search with `-i: true`, expect matches regardless of case
3. `grep_files_with_matches_mode` -- output_mode "files_with_matches" returns only file paths
4. `grep_count_mode` -- output_mode "count" returns `path:count` format
5. `grep_context_lines` -- `-C: 1` includes 1 line before and after each match
6. `grep_after_context` -- `-A: 2` includes 2 lines after each match
7. `grep_before_context` -- `-B: 1` includes 1 line before each match
8. `grep_path_scope` -- Scoped to "Lens/" only returns matches from Lens folder
9. `grep_no_matches` -- Pattern that matches nothing returns "No matches found."
10. `grep_invalid_regex` -- Invalid regex pattern returns error
11. `grep_head_limit` -- `head_limit: 1` in files_with_matches mode returns only 1 file
12. `grep_multiple_files` -- Matches across multiple documents returned in sorted path order

For test setup, use `Server::new_for_test()` + create Y.Docs with known content via the existing bare Y.Doc pattern (create doc, insert text, add to server docs DashMap, rebuild resolver). Write a test helper `create_test_doc(server, doc_id, content)` that:
- Creates a Y.Doc, inserts `content` into `TextRef("contents")`
- Inserts it into `server.docs()` wrapped in `DocWithSyncKv::new_in_memory(doc)`
- After all docs created, sets up the resolver via `server.doc_resolver().rebuild(server.docs())`

Also write these infrastructure tests in `session.rs`:
13. `read_docs_starts_empty` -- New session has empty read_docs HashSet
14. `read_docs_can_be_modified` -- Can insert/check doc_ids via get_session_mut

And in `read.rs` (or as integration test in `router.rs`):
15. `read_records_doc_in_session` -- After a successful read, the session's read_docs contains the doc_id

For the infrastructure changes needed to make tests compile (but NOT pass):
- Add `regex = "1"` to `crates/relay/Cargo.toml` dependencies
- Add `pub read_docs: HashSet<String>` to `McpSession` in `session.rs` (with `use std::collections::HashSet;`), initialize to `HashSet::new()` in `create_session`
- Change `dispatch_tool` signature in `tools/mod.rs` to accept `session_id: &str` as second parameter
- Update `handle_tools_call` in `router.rs` to extract session_id from the validated session and pass it to `dispatch_tool`. The session_id is available: in the `validate_session` call, the `session_id` parameter is `Option<&str>`. After validation succeeds, pass `session_id.unwrap()` (safe because validate_session returned Ok).
- Update `read::execute` signature to accept `session_id: &str` as second parameter (between server and arguments)
- Add `pub mod grep;` to `tools/mod.rs`
- Add grep to `tool_definitions()` with schema: `name: "grep"`, `description: "Search document contents using regex patterns. Returns matching lines with context. Mirrors ripgrep output format."`, required: ["pattern"], properties: pattern (string), path (string, optional folder scope), output_mode (string enum: content/files_with_matches/count, default files_with_matches), -i (bool), -C (number), -A (number), -B (number), head_limit (number)

Commit RED: `test(04-01): add failing tests for grep tool, session read-tracking, and dispatch_tool threading`

**GREEN phase -- Implement to pass all tests:**

1. **`session.rs`:** `read_docs: HashSet<String>` already added in RED. No further changes needed.

2. **`read.rs`:** After successfully resolving the doc and reading content, record the doc_id in the session:
   ```rust
   if let Some(mut session) = server.mcp_sessions.get_session_mut(session_id) {
       session.read_docs.insert(doc_info.doc_id.clone());
   }
   ```
   Do this AFTER the doc content is successfully read (not before), so only successful reads are tracked.

3. **`tools/mod.rs` dispatch_tool:** Add `session_id` parameter. Route `"grep"` to `grep::execute(server, arguments)`. Pass `session_id` to `read::execute(server, session_id, arguments)`. Other tools (glob, get_links) keep their existing signatures.

4. **`router.rs` handle_tools_call:** Extract session_id and pass to dispatch_tool. The session_id comes from the transport layer (already available as parameter to `dispatch_request`). In `handle_tools_call`, accept `session_id: &str` parameter and pass it through. Update `dispatch_request` to pass it:
   ```rust
   "tools/call" => {
       if let Err(err_resp) = validate_session(sessions, session_id, &request.id) {
           return (err_resp, None);
       }
       // session_id is Some(&str) here since validate_session passed
       (
           handle_tools_call(server, session_id.unwrap(), request.id.clone(), request.params.as_ref()),
           None,
       )
   }
   ```

5. **`grep.rs` implementation:**
   - Parse parameters: pattern (required), path (optional scope), output_mode (default "files_with_matches"), -i (default false), -C (default 0), -A (default: -C value), -B (default: -C value), head_limit (default 0 = unlimited)
   - Build regex with `regex::RegexBuilder::new(pattern).case_insensitive(case_insensitive).build()`
   - Get all paths from resolver, sort alphabetically for deterministic output
   - Filter by path scope if provided (path starts with `scope/` or equals scope)
   - For each document: resolve path -> read Y.Doc content -> split into lines -> find regex matches
   - Output formatting by mode:
     - `content`: `{path}:{line_num}:{line_text}` with context lines. Use `--` separator between non-adjacent match groups (ripgrep convention). Line numbers are 1-indexed.
     - `files_with_matches`: one path per line
     - `count`: `{path}:{match_count}` per file
   - Apply head_limit: in files_with_matches/count mode, limit number of files. In content mode, limit number of output lines.
   - Return "No matches found." if no matches anywhere.
   - Use a helper fn `read_doc_content(server, doc_id) -> Option<String>` to read Y.Doc text (same pattern as read tool).
   - For context lines with overlapping ranges (adjacent matches), merge ranges to avoid duplicate output lines.

Commit GREEN: `feat(04-01): implement grep tool, session read-tracking, dispatch_tool session threading`

**REFACTOR phase (if needed):** Only if obvious cleanup exists. Run all tests to confirm passing.

  </action>
  <verify>
    Run: `CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo test --manifest-path=/home/penguin/code/lens-relay/ws3/crates/relay/Cargo.toml -- --nocapture 2>&1 | tail -30`
    All tests pass including new grep tests, session tests, and read-tracking tests.
    Existing tests (router, read format, session, glob, get_links) still pass.
  </verify>
  <done>
    - grep tool returns matching lines in ripgrep format (path:line:content) with context support
    - grep supports files_with_matches, content, count output modes
    - grep supports case-insensitive search, path scoping, head_limit
    - Session read_docs HashSet tracks which docs were read
    - dispatch_tool accepts session_id, read tool records reads
    - All existing + new tests pass
  </done>
</task>

</tasks>

<verification>
- `cargo test` passes all tests (existing + new)
- `cargo build` compiles without warnings related to new code
- grep tool definition appears in tool_definitions() (verified by existing tools/list test count update: 3 -> 4 tools)
- Update the `tools_list_returns_three_tools` test in router.rs to expect 4 tools (rename to `tools_list_returns_four_tools`)
</verification>

<success_criteria>
- grep tool executes regex searches across Y.Doc content with line-numbered output
- Session infrastructure ready for read-before-edit enforcement (Plan 02)
- No regressions in existing MCP tools
</success_criteria>

<output>
After completion, create `.planning/phases/04-mcp-search-edit-tools/04-01-SUMMARY.md`
</output>
