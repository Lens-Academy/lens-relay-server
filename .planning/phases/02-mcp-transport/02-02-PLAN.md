---
phase: 02-mcp-transport
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - crates/relay/src/mcp/transport.rs
  - crates/relay/src/mcp/mod.rs
  - crates/relay/src/server.rs
  - crates/relay/src/lib.rs
autonomous: false

must_haves:
  truths:
    - "POST /mcp with an initialize request returns 200 with JSON-RPC response and Mcp-Session-Id header"
    - "POST /mcp with a notification returns 202 Accepted with no body"
    - "POST /mcp with a tools/list request and valid session ID returns 200 with tools array"
    - "POST /mcp without session ID on non-initialize request returns 400 Bad Request"
    - "POST /mcp with unknown session ID returns 404 Not Found"
    - "DELETE /mcp with valid session ID removes the session and returns 200"
    - "An MCP client (Claude Code or MCP Inspector) can complete the full initialize -> initialized -> tools/list flow"
  artifacts:
    - path: "crates/relay/src/mcp/transport.rs"
      provides: "Axum handlers for POST /mcp, GET /mcp, DELETE /mcp"
      contains: "handle_mcp_post"
    - path: "crates/relay/src/lib.rs"
      provides: "pub mod mcp declaration"
      contains: "pub mod mcp"
    - path: "crates/relay/src/server.rs"
      provides: "SessionManager in Server struct, /mcp route"
      contains: "mcp_sessions"
  key_links:
    - from: "crates/relay/src/mcp/transport.rs"
      to: "crates/relay/src/mcp/router.rs"
      via: "calls dispatch_request and handle_notification from router"
      pattern: "router::dispatch_request"
    - from: "crates/relay/src/mcp/transport.rs"
      to: "crates/relay/src/server.rs"
      via: "accesses server.mcp_sessions via State<Arc<Server>>"
      pattern: "server\\.mcp_sessions"
    - from: "crates/relay/src/server.rs"
      to: "crates/relay/src/mcp/transport.rs"
      via: "routes() adds /mcp endpoint with handlers"
      pattern: "route.*mcp.*handle_mcp"
---

<objective>
Wire the MCP protocol engine into the relay server as an HTTP endpoint at `/mcp`, handling POST (JSON-RPC messages), GET (405 for now), and DELETE (session termination).

Purpose: This completes Phase 2 by making the MCP transport accessible over HTTP. The protocol logic from Plan 01 is tested; this plan adds the HTTP layer and server integration.

Output: A working `/mcp` endpoint on the relay server that MCP clients can connect to.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-mcp-transport/02-RESEARCH.md
@.planning/phases/02-mcp-transport/02-01-SUMMARY.md
@crates/relay/src/server.rs (Server struct, routes(), AppError pattern)
@crates/relay/src/lib.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create transport.rs and integrate MCP into the server</name>
  <files>
    crates/relay/src/mcp/transport.rs
    crates/relay/src/mcp/mod.rs
    crates/relay/src/server.rs
    crates/relay/src/lib.rs
  </files>
  <action>
    Create `transport.rs` with three Axum handlers:

    1. `handle_mcp_post(State(server), headers, body)` -> Response:
       - Parse body as serde_json::Value. On parse failure, return 200 with JSON-RPC parse error (-32700).
       - Check if message has "id" field (request vs notification).
       - For notifications: extract session ID from headers (case-insensitive, Axum handles this), call `router::handle_notification`, return 202 Accepted.
       - For requests: check method name.
         - If method is "initialize": call `router::dispatch_request` (no session required). Return 200 with JSON body. Set `mcp-session-id` response header to the new session ID returned by dispatch_request.
         - If method is anything else: extract session ID from `mcp-session-id` header. If missing, return 400 with JSON error body. If present but unknown (session lookup fails), return 404 with JSON error body. Otherwise call `router::dispatch_request`, return 200 with JSON body.
       - Content-Type response header: `application/json` for all JSON responses.

    2. `handle_mcp_get()` -> (StatusCode, &'static str):
       - Return 405 Method Not Allowed with message "SSE not supported yet".

    3. `handle_mcp_delete(State(server), headers)` -> Response:
       - Extract session ID from `mcp-session-id` header.
       - If missing, return 400.
       - Call `session_manager.remove_session(id)`.
       - If session existed, return 200. If not found, return 404.

    Update `mod.rs` to add `pub mod transport;`

    Update `lib.rs` to add `pub mod mcp;`

    Update `server.rs`:
    - Add `use crate::mcp::session::SessionManager;` import
    - Add `mcp_sessions: Arc<SessionManager>` field to Server struct
    - Initialize it in `Server::new()` as `Arc::new(SessionManager::new())`
    - In `routes()`, add: `.route("/mcp", post(handle_mcp_post).get(handle_mcp_get).delete(handle_mcp_delete))`
    - Add `use crate::mcp::transport::{handle_mcp_post, handle_mcp_get, handle_mcp_delete};`

    Important: The `dispatch_request` and `handle_notification` functions in router.rs take `&SessionManager` directly. The transport.rs handler accesses `server.mcp_sessions` and passes the reference. The router has NO dependency on Server -- only on SessionManager. This keeps the protocol logic decoupled from Axum.

    For the mcp_sessions field, make it `pub(crate)` so transport.rs can access it from the server state.
  </action>
  <verify>
    ```bash
    CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo build --manifest-path=crates/Cargo.toml -p relay 2>&1 | tail -10
    CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo test --manifest-path=crates/Cargo.toml -p relay 2>&1 | tail -10
    ```
    Build succeeds with no errors. All existing tests still pass.
  </verify>
  <done>
    The `/mcp` endpoint is registered in the router. `cargo build` succeeds. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Start relay server and verify MCP endpoint with curl</name>
  <files>
    (no files modified -- verification only)
  </files>
  <action>
    Start the local relay server (if not already running):
    ```bash
    CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo run --manifest-path=crates/Cargo.toml --bin relay -- serve --port 8390 &
    ```
    Use port 8390 (ws3 MCP testing, avoids conflict with ws1/ws2 ports).

    Test the full MCP lifecycle with curl:

    1. Initialize:
    ```bash
    curl -s -D- -X POST http://localhost:8390/mcp \
      -H "Content-Type: application/json" \
      -d '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}'
    ```
    Expect: 200, JSON body with protocolVersion + capabilities + serverInfo, `mcp-session-id` header in response.

    2. Initialized notification (using session ID from step 1):
    ```bash
    curl -s -D- -X POST http://localhost:8390/mcp \
      -H "Content-Type: application/json" \
      -H "mcp-session-id: SESSION_ID_FROM_STEP_1" \
      -d '{"jsonrpc":"2.0","method":"notifications/initialized"}'
    ```
    Expect: 202 Accepted, empty or minimal body.

    3. Tools list:
    ```bash
    curl -s -X POST http://localhost:8390/mcp \
      -H "Content-Type: application/json" \
      -H "mcp-session-id: SESSION_ID_FROM_STEP_1" \
      -d '{"jsonrpc":"2.0","id":2,"method":"tools/list"}'
    ```
    Expect: 200, JSON with `{"tools":[]}`.

    4. Ping:
    ```bash
    curl -s -X POST http://localhost:8390/mcp \
      -H "Content-Type: application/json" \
      -H "mcp-session-id: SESSION_ID_FROM_STEP_1" \
      -d '{"jsonrpc":"2.0","id":3,"method":"ping"}'
    ```
    Expect: 200, JSON with `{"result":{}}`.

    5. Missing session ID:
    ```bash
    curl -s -D- -X POST http://localhost:8390/mcp \
      -H "Content-Type: application/json" \
      -d '{"jsonrpc":"2.0","id":4,"method":"tools/list"}'
    ```
    Expect: 400 Bad Request.

    6. DELETE session:
    ```bash
    curl -s -D- -X DELETE http://localhost:8390/mcp \
      -H "mcp-session-id: SESSION_ID_FROM_STEP_1"
    ```
    Expect: 200.

    7. Verify session is gone:
    ```bash
    curl -s -D- -X POST http://localhost:8390/mcp \
      -H "Content-Type: application/json" \
      -H "mcp-session-id: SESSION_ID_FROM_STEP_1" \
      -d '{"jsonrpc":"2.0","id":5,"method":"tools/list"}'
    ```
    Expect: 404 Not Found.

    Kill the test server after verification:
    ```bash
    lsof -ti:8390 | xargs kill
    ```
  </action>
  <verify>
    All 7 curl commands return the expected HTTP status codes and response bodies as described above.
  </verify>
  <done>
    The MCP endpoint correctly handles the full lifecycle: initialize -> initialized notification -> tool requests -> session deletion. HTTP status codes match the MCP spec (200/202/400/404).
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete MCP Streamable HTTP transport at /mcp endpoint on the relay server. Supports the full MCP lifecycle: initialize (with session ID assignment), notifications/initialized, ping, tools/list (empty), tools/call (stub error), and session deletion via DELETE.
  </what-built>
  <how-to-verify>
    The relay server should already be stopped from Task 2. Start it fresh:
    ```bash
    cd /home/penguin/code/lens-relay/ws3
    CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo run --manifest-path=crates/Cargo.toml --bin relay -- serve --port 8390 &
    ```

    Option A (MCP Inspector -- if available):
    1. Configure MCP Inspector to connect to `http://localhost:8390/mcp` (or `http://dev.vps:8390/mcp`)
    2. Verify it completes initialization handshake
    3. Verify tools/list returns empty array

    Option B (Claude Code -- quick test):
    1. Add to MCP config: `{"url": "http://localhost:8390/mcp"}`
    2. Verify Claude Code connects and shows "lens-relay" as server name
    3. Verify no tools listed (expected -- tools come in Phase 3-4)

    After verification, stop the server: `lsof -ti:8390 | xargs kill`
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
```bash
# Full build
CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo build --manifest-path=crates/Cargo.toml -p relay 2>&1 | tail -5

# All tests pass
CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo test --manifest-path=crates/Cargo.toml -p relay 2>&1 | tail -10

# MCP module exists with expected structure
ls -la crates/relay/src/mcp/

# Key types are accessible
grep -r "pub mod mcp" crates/relay/src/lib.rs
grep "mcp_sessions" crates/relay/src/server.rs
grep "/mcp" crates/relay/src/server.rs
```
</verification>

<success_criteria>
- `/mcp` endpoint accepts POST requests and returns valid JSON-RPC responses
- Initialize flow creates a session and returns session ID in header
- Non-initialize requests without session ID return 400
- Unknown session IDs return 404
- DELETE removes the session
- An MCP client can complete the initialize -> initialized -> tools/list flow
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-transport/02-02-SUMMARY.md`
</output>
