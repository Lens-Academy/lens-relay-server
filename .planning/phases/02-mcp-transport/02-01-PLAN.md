---
phase: 02-mcp-transport
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/relay/src/mcp/mod.rs
  - crates/relay/src/mcp/jsonrpc.rs
  - crates/relay/src/mcp/session.rs
  - crates/relay/src/mcp/router.rs
autonomous: true

must_haves:
  truths:
    - "A JSON body with an id field parses as a Request; without id parses as a Notification"
    - "An initialize request creates a new session and returns server capabilities with session ID"
    - "A ping request returns an empty result object"
    - "A tools/list request returns a tools array (empty for now)"
    - "A tools/call request without a valid initialized session returns an error"
    - "An unknown method returns a JSON-RPC method-not-found error (-32601)"
    - "Sessions can be created, looked up by ID, marked initialized, and removed"
  artifacts:
    - path: "crates/relay/src/mcp/mod.rs"
      provides: "Module declarations and re-exports"
    - path: "crates/relay/src/mcp/jsonrpc.rs"
      provides: "JSON-RPC 2.0 message types (Request, Notification, Response, Error)"
      contains: "JsonRpcRequest"
    - path: "crates/relay/src/mcp/session.rs"
      provides: "McpSession struct and SessionManager with DashMap"
      contains: "SessionManager"
    - path: "crates/relay/src/mcp/router.rs"
      provides: "Method dispatch and MCP handlers (initialize, ping, tools/list, tools/call stub)"
      contains: "dispatch_request"
  key_links:
    - from: "crates/relay/src/mcp/router.rs"
      to: "crates/relay/src/mcp/jsonrpc.rs"
      via: "uses JsonRpcRequest, JsonRpcResponse, JsonRpcError types"
      pattern: "use super::jsonrpc"
    - from: "crates/relay/src/mcp/router.rs"
      to: "crates/relay/src/mcp/session.rs"
      via: "creates and validates sessions via SessionManager"
      pattern: "SessionManager"
---

<objective>
Implement the MCP protocol engine: JSON-RPC 2.0 message types, session management, and method dispatch with full test coverage.

Purpose: These are the testable core components of the MCP transport. Every method handler has clear input/output contracts: given a JSON-RPC request, return the correct response. TDD forces the protocol behavior to be correct before wiring into Axum.

Output: Four source files in `crates/relay/src/mcp/` with inline `#[cfg(test)]` modules proving all protocol behavior.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-mcp-transport/02-RESEARCH.md
@crates/relay/src/server.rs (lines 420-440 for Server struct fields and DashMap pattern)
@crates/relay/src/lib.rs (module declarations)
</context>

<feature>
  <name>MCP Protocol Engine (JSON-RPC + Sessions + Method Dispatch)</name>
  <files>
    crates/relay/src/mcp/mod.rs
    crates/relay/src/mcp/jsonrpc.rs
    crates/relay/src/mcp/session.rs
    crates/relay/src/mcp/router.rs
  </files>
  <behavior>
    JSON-RPC message parsing (jsonrpc.rs):
    - `{"jsonrpc":"2.0","id":1,"method":"ping"}` -> JsonRpcMessage::Request with id=1, method="ping"
    - `{"jsonrpc":"2.0","method":"notifications/initialized"}` -> JsonRpcMessage::Notification with method="notifications/initialized"
    - `{"jsonrpc":"2.0","id":"abc","method":"tools/list"}` -> Request with string id "abc"
    - `{"jsonrpc":"2.0","id":null,"method":"ping"}` -> Request with null id (id field present = request)
    - Malformed JSON -> parse error
    - Missing method field -> invalid request error

    Session management (session.rs):
    - create_session(version, client_info) -> returns unique 32-char session ID
    - get_session(valid_id) -> returns Some(session)
    - get_session(invalid_id) -> returns None
    - mark_initialized(session_id) -> session.initialized becomes true
    - remove_session(id) -> session no longer accessible
    - Two created sessions have different IDs

    Method dispatch (router.rs):
    - initialize request -> creates session, returns {protocolVersion, capabilities:{tools:{}}, serverInfo:{name,version}}
    - ping request -> returns empty result {}
    - tools/list request -> returns {tools: []} (empty array for Phase 2)
    - tools/call request with initialized session -> returns error "No tools available" (stub for Phase 2)
    - tools/call request without session -> returns error about missing session
    - unknown method "foo/bar" -> returns -32601 method not found error
    - notifications/initialized with valid session -> marks session initialized (return value indicates success)
    - notifications/cancelled -> no-op (logged, no error)

    Module exports (mod.rs):
    - Re-export key types: SessionManager, JsonRpcMessage, JsonRpcResponse, dispatch_request, handle_notification
  </behavior>
  <implementation>
    Follow the research patterns closely (02-RESEARCH.md has near-complete code).

    jsonrpc.rs:
    - JsonRpcRequest: jsonrpc (String), id (serde_json::Value), method (String), params (Option<Value>)
    - JsonRpcNotification: jsonrpc (String), method (String), params (Option<Value>)
    - JsonRpcMessage enum: Request(JsonRpcRequest) | Notification(JsonRpcNotification)
    - parse_message(body: &Value) -> Result<JsonRpcMessage, JsonRpcError>: check for "id" field presence to distinguish
    - JsonRpcResponse: jsonrpc (String), id (Value), result (Option<Value>), error (Option<JsonRpcError>)
    - JsonRpcError: code (i64), message (String), data (Option<Value>)
    - Helper: success_response(id, result) and error_response(id, code, message)
    - Constants for standard error codes: PARSE_ERROR (-32700), INVALID_REQUEST (-32600), METHOD_NOT_FOUND (-32601), INVALID_PARAMS (-32602), INTERNAL_ERROR (-32603)

    session.rs:
    - McpSession: session_id, protocol_version, client_info (Option<Value>), initialized (bool), created_at (Instant), last_activity (Instant)
    - SessionManager: DashMap<String, McpSession>
    - new() -> Self
    - create_session(protocol_version, client_info) -> String (session_id, uses nanoid!(32))
    - get_session(id) -> Option<Ref>
    - get_session_mut(id) -> Option<RefMut> (for updating last_activity and initialized)
    - mark_initialized(id) -> bool (returns whether session existed and was updated)
    - remove_session(id) -> bool

    router.rs:
    - dispatch_request(sessions: &SessionManager, session_id: Option<&str>, request: &JsonRpcRequest) -> (JsonRpcResponse, Option<String>)
      The Option<String> is the new session ID to include in response headers (only set for initialize).
    - handle_notification(sessions: &SessionManager, session_id: Option<&str>, notification: &JsonRpcNotification)
    - handle_initialize(sessions, id, params) -> (JsonRpcResponse, String)
    - handle_ping(id) -> JsonRpcResponse
    - handle_tools_list(id) -> JsonRpcResponse
    - handle_tools_call(sessions, session_id, id, params) -> JsonRpcResponse
    - validate_session(sessions, session_id) -> Result<(), JsonRpcResponse>: checks session exists and is initialized

    mod.rs:
    - pub mod jsonrpc; pub mod session; pub mod router;
    - pub use of key types

    Testing approach:
    - All tests use inline #[cfg(test)] modules (codebase convention)
    - jsonrpc tests: parse various JSON bodies, verify correct message type and field values
    - session tests: create/get/mark/remove lifecycle
    - router tests: call dispatch_request with test fixtures, verify response content
    - Router tests create a SessionManager directly (no Server dependency needed)
    - Use CARGO_PKG_VERSION env var in tests (set by Cargo automatically)
  </implementation>
</feature>

<verification>
```bash
# Build the mcp module
CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo build --manifest-path=crates/Cargo.toml -p relay 2>&1 | tail -5

# Run only MCP tests
CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo test --manifest-path=crates/Cargo.toml -p relay mcp 2>&1 | tail -20

# Verify all tests pass (no regressions)
CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo test --manifest-path=crates/Cargo.toml -p relay 2>&1 | tail -10
```
</verification>

<success_criteria>
- All MCP-related tests pass (JSON-RPC parsing, session lifecycle, method dispatch)
- `cargo build` succeeds with no warnings in mcp module
- No regressions in existing relay tests
- Each truth in must_haves is covered by at least one test
</success_criteria>

<output>
After completion, create `.planning/phases/02-mcp-transport/02-01-SUMMARY.md`
</output>
