---
phase: 03-mcp-read-only-tools
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - crates/relay/Cargo.toml
  - crates/relay/src/mcp/mod.rs
  - crates/relay/src/mcp/router.rs
  - crates/relay/src/mcp/transport.rs
  - crates/relay/src/mcp/tools/mod.rs
  - crates/relay/src/mcp/tools/read.rs
  - crates/relay/src/mcp/tools/glob.rs
  - crates/relay/src/mcp/tools/get_links.rs
  - crates/relay/src/server.rs
autonomous: false

must_haves:
  truths:
    - "An AI assistant can call glob with '**/*.md' and receive all document paths"
    - "An AI assistant can call read with a document path and receive content in cat -n format"
    - "An AI assistant can call get_links for a document and receive backlinks and forward links"
    - "tools/list returns definitions for read, glob, and get_links with correct schemas"
    - "Tool execution errors return isError:true in successful JSON-RPC response, not protocol errors"
  artifacts:
    - path: "crates/relay/src/mcp/tools/mod.rs"
      provides: "Tool registry, definitions, dispatch"
      exports: ["tool_definitions", "dispatch_tool"]
    - path: "crates/relay/src/mcp/tools/read.rs"
      provides: "read tool: document content in cat -n format"
      exports: ["execute"]
    - path: "crates/relay/src/mcp/tools/glob.rs"
      provides: "glob tool: pattern matching against document paths"
      exports: ["execute"]
    - path: "crates/relay/src/mcp/tools/get_links.rs"
      provides: "get_links tool: backlinks and forward links"
      exports: ["execute"]
  key_links:
    - from: "crates/relay/src/mcp/router.rs"
      to: "crates/relay/src/mcp/tools/mod.rs"
      via: "tools/list calls tool_definitions(), tools/call calls dispatch_tool()"
      pattern: "tools::(tool_definitions|dispatch_tool)"
    - from: "crates/relay/src/mcp/tools/*.rs"
      to: "crates/y-sweet-core/src/doc_resolver.rs"
      via: "all tools use server.doc_resolver to translate paths"
      pattern: "doc_resolver\\.(resolve_path|path_for_uuid|all_paths)"
    - from: "crates/relay/src/mcp/transport.rs"
      to: "crates/relay/src/mcp/router.rs"
      via: "transport passes &Arc<Server> to router dispatch"
      pattern: "dispatch_request.*server"
    - from: "crates/relay/src/server.rs"
      to: "crates/y-sweet-core/src/doc_resolver.rs"
      via: "Server holds doc_resolver, builds at startup"
      pattern: "doc_resolver.*rebuild"
---

<objective>
Implement the three MCP tools (read, glob, get_links), wire them into the existing MCP transport, and integrate the DocumentResolver into the relay server. This makes the MCP endpoint fully functional for AI assistant document access.

Purpose: This is the payoff plan -- it connects the Phase 2 MCP transport to actual document data via the Phase 3 Plan 01 DocumentResolver. After this, an AI assistant can discover, read, and navigate the knowledge base.

Output: Three tool modules under `mcp/tools/`, updated router dispatch, DocumentResolver in Server struct, live verification via curl.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-mcp-read-only-tools/03-RESEARCH.md
@.planning/phases/03-mcp-read-only-tools/03-01-SUMMARY.md

Key codebase files:
@crates/relay/src/mcp/router.rs (dispatch_request, handle_tools_list, handle_tools_call stubs to update)
@crates/relay/src/mcp/transport.rs (handle_mcp_post -- needs to pass &Arc<Server> to router)
@crates/relay/src/mcp/mod.rs (add pub mod tools)
@crates/relay/src/server.rs (Server struct -- add doc_resolver field, build in startup_reindex)
@crates/relay/Cargo.toml (add glob-match dependency)
@crates/y-sweet-core/src/doc_resolver.rs (DocumentResolver from Plan 01)
@crates/y-sweet-core/src/link_indexer.rs (read_backlinks_array pub, extract_wikilinks, resolve_links_to_uuids, find_all_folder_docs)
@crates/y-sweet-core/src/link_parser.rs (extract_wikilinks)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Tool modules + router wiring + server integration</name>
  <files>
    crates/relay/Cargo.toml
    crates/relay/src/mcp/mod.rs
    crates/relay/src/mcp/router.rs
    crates/relay/src/mcp/transport.rs
    crates/relay/src/mcp/tools/mod.rs
    crates/relay/src/mcp/tools/read.rs
    crates/relay/src/mcp/tools/glob.rs
    crates/relay/src/mcp/tools/get_links.rs
    crates/relay/src/server.rs
  </files>
  <action>
    **Step 1: Add glob-match dependency**
    Add `glob-match = "0.2"` to `crates/relay/Cargo.toml` under `[dependencies]`.

    **Step 2: Create tool modules**

    Create `crates/relay/src/mcp/tools/mod.rs`:
    - `pub mod read; pub mod glob; pub mod get_links;`
    - `pub fn tool_definitions() -> Vec<Value>` returning the three tool schemas (see RESEARCH.md Pattern 2 for exact JSON)
    - `pub fn dispatch_tool(server: &Arc<Server>, name: &str, arguments: &Value) -> Value` that matches on tool name, calls the right execute fn, and wraps result in MCP CallToolResult format
    - Helper fns `tool_success(text: &str) -> Value` and `tool_error(msg: &str) -> Value` for the `content[]/isError` wrapper
    - Unknown tool name returns tool_error("Unknown tool: {name}")

    Create `crates/relay/src/mcp/tools/read.rs`:
    - `pub fn execute(server: &Arc<Server>, arguments: &Value) -> Result<String, String>`
    - Parse `file_path` (required string), `offset` (optional number, default 0), `limit` (optional number, default 2000)
    - Use `server.doc_resolver().resolve_path(file_path)` to get DocInfo
    - If not found: return Err("Error: Document not found: {file_path}")
    - Read Y.Doc content: `server.docs().get(&doc_info.doc_id)`, get awareness, read lock, transact, get_text("contents"), get_string
    - IMPORTANT: Read content into owned String, then drop all guards (awareness guard, DashMap ref) BEFORE formatting
    - Format as cat -n: `format!("{:>6}\t{}", line_num, truncated_line)` where line_num is 1-indexed, lines truncated at 2000 chars
    - Apply offset (skip first N lines, 0-indexed so offset=1 means start at line 1 which is the first line) and limit
    - NOTE on offset semantics: match Claude Code's Read tool -- offset is the line number to start from (1-indexed). So offset=5 means start reading from line 5. If offset is provided, it's 1-indexed. Internally: skip(offset.saturating_sub(1)) when offset > 0, skip(0) when offset is 0 or absent.
    - Return Ok(formatted_string)

    Create `crates/relay/src/mcp/tools/glob.rs`:
    - `pub fn execute(server: &Arc<Server>, arguments: &Value) -> Result<String, String>`
    - Parse `pattern` (required string), `path` (optional string, folder scope)
    - Get all paths from `server.doc_resolver().all_paths()`
    - Filter: if `path` is provided, only include paths starting with that prefix (add trailing "/" if not present, to match "Lens/" not "Lens Edu/")
    - Use `glob_match::glob_match(pattern, &path)` to filter
    - Sort alphabetically
    - Return Ok(paths joined by "\n"), or Ok("No matches found.") if empty

    Create `crates/relay/src/mcp/tools/get_links.rs`:
    - `pub fn execute(server: &Arc<Server>, arguments: &Value) -> Result<String, String>`
    - Parse `file_path` (required string)
    - Resolve to DocInfo via doc_resolver
    - If not found: return Err("Error: Document not found: {file_path}")

    For backlinks:
    - Get the folder doc via `server.docs().get(&doc_info.folder_doc_id)`
    - Read backlinks_v0 Y.Map, call `link_indexer::read_backlinks_array(&backlinks_map, &txn, &doc_info.uuid)`
    - Each returned UUID -> resolve back to path via `server.doc_resolver().path_for_uuid(&uuid)`
    - Drop all guards after reading into owned Vec<String>

    For forward links -- concrete resolution algorithm:
    1. Get the content doc via `server.docs().get(&doc_info.doc_id)`.
    2. Read Y.Text("contents"), call `get_string(&txn)` into an owned `String`, then drop all guards (awareness guard, DashMap ref).
    3. Call `link_parser::extract_wikilinks(&content)` to get `Vec<String>` of link names. Note: `extract_wikilinks` already handles aliases like `[[Target|Display]]` (returning just "Target") and anchors like `[[Page#Section]]` -- but verify by checking link_parser.rs. If `extract_wikilinks` does NOT strip anchors, strip them here: `link_name.split('#').next().unwrap()`.
    4. Get all document paths: `let all_paths = server.doc_resolver().all_paths();`
    5. For each `link_name` in the extracted wikilinks:
       a. Normalize: `let normalized = link_name.to_lowercase();`
       b. Iterate `&all_paths`. For each `path`:
          - Extract basename: `path.rsplit('/').next().unwrap()` (e.g., "Lens/Notes/Ideas.md" -> "Ideas.md")
          - Strip `.md` suffix: `basename.strip_suffix(".md").unwrap_or(basename)` (e.g., "Ideas.md" -> "Ideas")
          - Compare case-insensitively: `basename_no_ext.to_lowercase() == normalized`
       c. First match wins -- `break` out of the inner path loop.
       d. If a match is found, push `path.clone()` into `forward_links: Vec<String>`.
    6. Deduplicate `forward_links`: sort, then `dedup()` -- a document may contain multiple wikilinks resolving to the same target (e.g., `[[Cell]]` and `[[cell]]`).
    7. The result is already sorted from the dedup step.

    Format output:
    ```
    Backlinks (documents linking to this):
    - Lens/Biology 101.md
    - Lens Edu/Syllabus.md

    Forward links (documents this links to):
    - Lens/Cell Theory.md
    ```
    If a section is empty, show "- (none)". Always show both sections.

    **Step 3: Update router to use tools and accept &Arc<Server>**

    Update `crates/relay/src/mcp/router.rs`:
    - Change `dispatch_request` signature: replace `sessions: &SessionManager` with `server: &Arc<Server>`. Extract sessions as `&server.mcp_sessions` internally.
    - Change `handle_tools_list` to call `tools::tool_definitions()` and return them in the response
    - Change `handle_tools_call` to accept `server: &Arc<Server>`, parse `params.name` and `params.arguments`, call `tools::dispatch_tool(server, name, arguments)`, return the result as a successful JSON-RPC response
    - Update `validate_session` to accept `sessions: &SessionManager` (extract from server in caller)
    - Import `super::tools` and `crate::server::Server`
    - Update ALL existing tests to work with the new signature. The tests currently create a bare SessionManager. They'll need to either: (a) create a minimal Server or (b) the functions they test should still work. Since tests for initialize/ping/unknown_method don't need Server access, consider: make dispatch_request take `&Arc<Server>` and update test helpers to construct a minimal Server. OR: keep a test-only constructor. The simplest approach: add a `#[cfg(test)] pub fn new_for_test() -> Arc<Server>` that creates a Server with empty docs, no store, no auth, no search -- just enough for session management. Look at Server::new() to see what's minimally required.

    **Step 4: Update transport to pass &Arc<Server> to router**

    Update `crates/relay/src/mcp/transport.rs`:
    - In `handle_mcp_post`, change the router calls from `router::dispatch_request(&server.mcp_sessions, ...)` to `router::dispatch_request(&server, ...)`
    - The `handle_notification` can keep taking `&server.mcp_sessions` OR also take `&server` -- your choice based on what's cleaner
    - Update the module re-exports in `mcp/mod.rs` if needed

    **Step 5: Add DocumentResolver to Server and build at startup**

    Update `crates/relay/src/server.rs`:
    - Add `doc_resolver: Arc<DocumentResolver>` field to Server struct
    - Import `y_sweet_core::doc_resolver::DocumentResolver`
    - Initialize in Server::new(): `doc_resolver: Arc::new(DocumentResolver::new())`
    - Add public accessor: `pub fn doc_resolver(&self) -> &Arc<DocumentResolver>`
    - Add public accessor for docs if not already public: `pub fn docs(&self) -> &Arc<DashMap<String, DocWithSyncKv>>`
    - In `startup_reindex()`, after loading all docs and before building search index, call `self.doc_resolver.rebuild(&self.docs)`
    - Log: `tracing::info!("Document resolver built: {} documents", self.doc_resolver.all_paths().len())`

    **Step 6: Add pub mod tools to mcp/mod.rs**

    Update `crates/relay/src/mcp/mod.rs`:
    - Add `pub mod tools;`

    **Step 7: Verify compilation**
    Run `cargo build` to verify everything compiles cleanly.
  </action>
  <verify>
    ```bash
    cd /home/penguin/code/lens-relay/ws3 && CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo build --manifest-path=crates/relay/Cargo.toml 2>&1 | tail -5
    cd /home/penguin/code/lens-relay/ws3 && CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo test --manifest-path=crates/relay/Cargo.toml -- --nocapture 2>&1 | tail -20
    ```
    Build succeeds. All existing tests pass (including updated router tests).
  </verify>
  <done>
    - Three tool modules exist under mcp/tools/ with correct execute functions
    - tools/list returns read, glob, get_links definitions with Claude Code-matching schemas
    - tools/call dispatches to correct tool by name
    - Router accepts &Arc<Server>, transport passes it through
    - Server has doc_resolver field, built during startup_reindex
    - All existing tests updated and passing
    - cargo build succeeds
  </done>
</task>

<task type="auto">
  <name>Task 2: Live verification with relay server and test documents</name>
  <files>(no new files -- testing existing)</files>
  <action>
    Start the relay server locally and run the setup script to populate test documents. Then verify all three tools via curl against the live /mcp endpoint.

    **Start server:**
    ```bash
    cd /home/penguin/code/lens-relay/ws3
    CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo run --manifest-path=crates/Cargo.toml --bin relay -- serve --port 8390 &
    sleep 3
    cd lens-editor && npm run relay:setup
    ```
    Use port 8390 to avoid conflicts with ws1/ws2 servers.

    **Test sequence (curl):**

    1. Initialize session:
    ```bash
    curl -s -D- -X POST http://localhost:8390/mcp \
      -H 'Content-Type: application/json' \
      -d '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-03-26","clientInfo":{"name":"test","version":"1.0"}}}'
    ```
    Extract Mcp-Session-Id from response header.

    2. Send initialized notification:
    ```bash
    curl -s -X POST http://localhost:8390/mcp \
      -H 'Content-Type: application/json' \
      -H 'Mcp-Session-Id: SESSION_ID' \
      -d '{"jsonrpc":"2.0","method":"notifications/initialized"}'
    ```

    3. tools/list -- verify 3 tools returned:
    ```bash
    curl -s -X POST http://localhost:8390/mcp \
      -H 'Content-Type: application/json' \
      -H 'Mcp-Session-Id: SESSION_ID' \
      -d '{"jsonrpc":"2.0","id":2,"method":"tools/list"}' \
      | jq .
    ```

    4. glob -- list all documents:
    ```bash
    curl -s -X POST http://localhost:8390/mcp \
      -H 'Content-Type: application/json' \
      -H 'Mcp-Session-Id: SESSION_ID' \
      -d '{"jsonrpc":"2.0","id":3,"method":"tools/call","params":{"name":"glob","arguments":{"pattern":"**/*.md"}}}'
    ```

    5. read -- read a document (use first path from glob results):
    ```bash
    curl -s -X POST http://localhost:8390/mcp \
      -H 'Content-Type: application/json' \
      -H 'Mcp-Session-Id: SESSION_ID' \
      -d '{"jsonrpc":"2.0","id":4,"method":"tools/call","params":{"name":"read","arguments":{"file_path":"THE_PATH"}}}'
    ```

    6. read -- document not found:
    ```bash
    curl -s -X POST http://localhost:8390/mcp \
      -H 'Content-Type: application/json' \
      -H 'Mcp-Session-Id: SESSION_ID' \
      -d '{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"read","arguments":{"file_path":"Lens/NonExistent.md"}}}'
    ```

    7. get_links -- get links for a document:
    ```bash
    curl -s -X POST http://localhost:8390/mcp \
      -H 'Content-Type: application/json' \
      -H 'Mcp-Session-Id: SESSION_ID' \
      -d '{"jsonrpc":"2.0","id":6,"method":"tools/call","params":{"name":"get_links","arguments":{"file_path":"THE_PATH"}}}'
    ```

    8. Unknown tool:
    ```bash
    curl -s -X POST http://localhost:8390/mcp \
      -H 'Content-Type: application/json' \
      -H 'Mcp-Session-Id: SESSION_ID' \
      -d '{"jsonrpc":"2.0","id":7,"method":"tools/call","params":{"name":"unknown_tool","arguments":{}}}'
    ```

    **After testing, kill the server:**
    ```bash
    lsof -ti:8390 | xargs kill
    ```
  </action>
  <verify>
    After extracting SESSION_ID from the initialize response header, run each assertion. Replace SESSION_ID with the actual value.

    ```bash
    # Test 3: tools/list returns exactly 3 tools
    curl -s -X POST http://localhost:8390/mcp \
      -H 'Content-Type: application/json' \
      -H "Mcp-Session-Id: $SESSION_ID" \
      -d '{"jsonrpc":"2.0","id":2,"method":"tools/list"}' \
      | jq -e '.result.tools | length == 3'

    # Test 3b: tool names are read, glob, get_links
    curl -s -X POST http://localhost:8390/mcp \
      -H 'Content-Type: application/json' \
      -H "Mcp-Session-Id: $SESSION_ID" \
      -d '{"jsonrpc":"2.0","id":2,"method":"tools/list"}' \
      | jq -e '[.result.tools[].name] | sort == ["get_links", "glob", "read"]'

    # Test 4: glob returns content with isError absent or false
    curl -s -X POST http://localhost:8390/mcp \
      -H 'Content-Type: application/json' \
      -H "Mcp-Session-Id: $SESSION_ID" \
      -d '{"jsonrpc":"2.0","id":3,"method":"tools/call","params":{"name":"glob","arguments":{"pattern":"**/*.md"}}}' \
      | jq -e '.result.content[0].text | length > 0' \
      && echo "glob: PASS"

    # Test 4b: glob result has isError false or absent (not an error)
    curl -s -X POST http://localhost:8390/mcp \
      -H 'Content-Type: application/json' \
      -H "Mcp-Session-Id: $SESSION_ID" \
      -d '{"jsonrpc":"2.0","id":3,"method":"tools/call","params":{"name":"glob","arguments":{"pattern":"**/*.md"}}}' \
      | jq -e '(.result.isError // false) == false'

    # Test 5: read returns cat -n formatted content (line starts with spaces + digit + tab)
    curl -s -X POST http://localhost:8390/mcp \
      -H 'Content-Type: application/json' \
      -H "Mcp-Session-Id: $SESSION_ID" \
      -d "{\"jsonrpc\":\"2.0\",\"id\":4,\"method\":\"tools/call\",\"params\":{\"name\":\"read\",\"arguments\":{\"file_path\":\"$FIRST_DOC_PATH\"}}}" \
      | jq -e '.result.content[0].text | test("^ +[0-9]+\t")'

    # Test 6: read with bad path returns isError true
    curl -s -X POST http://localhost:8390/mcp \
      -H 'Content-Type: application/json' \
      -H "Mcp-Session-Id: $SESSION_ID" \
      -d '{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"read","arguments":{"file_path":"Lens/NonExistent.md"}}}' \
      | jq -e '.result.isError == true'

    # Test 6b: error message mentions "not found"
    curl -s -X POST http://localhost:8390/mcp \
      -H 'Content-Type: application/json' \
      -H "Mcp-Session-Id: $SESSION_ID" \
      -d '{"jsonrpc":"2.0","id":5,"method":"tools/call","params":{"name":"read","arguments":{"file_path":"Lens/NonExistent.md"}}}' \
      | jq -e '.result.content[0].text | test("not found"; "i")'

    # Test 7: get_links returns content with backlinks/forward links sections
    curl -s -X POST http://localhost:8390/mcp \
      -H 'Content-Type: application/json' \
      -H "Mcp-Session-Id: $SESSION_ID" \
      -d "{\"jsonrpc\":\"2.0\",\"id\":6,\"method\":\"tools/call\",\"params\":{\"name\":\"get_links\",\"arguments\":{\"file_path\":\"$FIRST_DOC_PATH\"}}}" \
      | jq -e '.result.content[0].text | (test("Backlinks") and test("Forward links"))'

    # Test 8: unknown tool returns isError true (tool-level, NOT JSON-RPC error)
    curl -s -X POST http://localhost:8390/mcp \
      -H 'Content-Type: application/json' \
      -H "Mcp-Session-Id: $SESSION_ID" \
      -d '{"jsonrpc":"2.0","id":7,"method":"tools/call","params":{"name":"unknown_tool","arguments":{}}}' \
      | jq -e '.result.isError == true and (.error | not)'
    ```

    All jq assertions exit 0 (jq -e exits non-zero if the expression evaluates to false or null).
    $SESSION_ID must be set from the initialize response. $FIRST_DOC_PATH must be set from the glob result.
  </verify>
  <done>
    All MCP tools respond correctly via the live /mcp endpoint. The three tools are functional end-to-end.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Three MCP tools (read, glob, get_links) wired into the relay server's /mcp endpoint. AI assistants can now discover, read, and navigate links between documents in the knowledge base.</what-built>
  <how-to-verify>
    The automated curl tests in Task 2 verify the core functionality. Review the curl output to confirm:

    1. `tools/list` returns exactly 3 tools: read, glob, get_links
    2. `glob` with `**/*.md` returns document paths from the knowledge base
    3. `read` returns document content with proper line numbers (cat -n format)
    4. `get_links` returns backlinks and forward links sections
    5. Error cases return `isError: true` (not protocol errors)

    If you want to test interactively, the server should still be running on port 8390 (or restart it).
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
```bash
# Full verification sequence
cd /home/penguin/code/lens-relay/ws3
CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo build --manifest-path=crates/relay/Cargo.toml
CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo test --manifest-path=crates/relay/Cargo.toml
CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo test --manifest-path=crates/y-sweet-core/Cargo.toml doc_resolver
```
Build succeeds, all unit tests pass, live curl tests pass.
</verification>

<success_criteria>
- tools/list returns read, glob, get_links with schemas matching Claude Code's Read and Glob tools
- glob("**/*.md") returns all document paths in "Folder/Name.md" format
- read("Lens/SomeDoc.md") returns content in cat -n format with 6-char right-aligned line numbers
- read with offset/limit returns partial content
- get_links returns both backlinks and forward links sections
- Tool errors return isError:true in successful JSON-RPC responses
- Unknown tool name returns tool-level error (not protocol error)
- DocumentResolver is built at startup and accessible to all tool handlers
- All existing MCP transport tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-mcp-read-only-tools/03-02-SUMMARY.md`
</output>
