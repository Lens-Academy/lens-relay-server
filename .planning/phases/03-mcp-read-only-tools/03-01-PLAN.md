---
phase: 03-mcp-read-only-tools
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - crates/y-sweet-core/src/doc_resolver.rs
  - crates/y-sweet-core/src/lib.rs
  - crates/y-sweet-core/src/link_indexer.rs
autonomous: true

must_haves:
  truths:
    - "A path like 'Lens/Photosynthesis.md' resolves to the correct doc UUID and relay_id"
    - "A UUID resolves back to the correct path"
    - "All document paths are enumerable for glob matching"
    - "Folder name derivation is centralized (not duplicated across modules)"
    - "read_backlinks_array is publicly accessible for get_links tool"
  artifacts:
    - path: "crates/y-sweet-core/src/doc_resolver.rs"
      provides: "DocumentResolver struct with bidirectional path<->UUID mapping"
      exports: ["DocumentResolver", "DocInfo"]
    - path: "crates/y-sweet-core/src/lib.rs"
      provides: "Module declaration for doc_resolver"
      contains: "pub mod doc_resolver"
  key_links:
    - from: "doc_resolver.rs"
      to: "link_indexer.rs"
      via: "uses extract_id_from_filemeta_entry, find_all_folder_docs, parse_doc_id"
      pattern: "link_indexer::(extract_id|find_all|parse_doc)"
---

<objective>
Build the DocumentResolver: a bidirectional cache mapping between user-facing document paths (`Lens/Photosynthesis.md`) and internal relay identifiers (relay_id, UUID, doc_id). This is the foundation all three MCP tools need.

Purpose: Every MCP tool call translates between user-facing paths and internal Y.Doc identifiers. Without a cached resolver, each tool call would scan all folder docs (O(n) per request). The resolver amortizes this to O(1) lookups.

Output: `crates/y-sweet-core/src/doc_resolver.rs` with tested DocumentResolver struct, plus `read_backlinks_array` made public in link_indexer.rs.
</objective>

<execution_context>
@/home/penguin/.claude/get-shit-done/workflows/execute-plan.md
@/home/penguin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-mcp-read-only-tools/03-RESEARCH.md

Key codebase files to reference:
@crates/y-sweet-core/src/link_indexer.rs (extract_id_from_filemeta_entry, find_all_folder_docs, parse_doc_id, read_backlinks_array)
@crates/y-sweet-core/src/lib.rs (add pub mod doc_resolver)
@crates/relay/src/server.rs (search_find_title_and_folder for folder name derivation pattern, startup_reindex for DashMap iteration pattern)
</context>

<feature>
  <name>DocumentResolver: Bidirectional Path-UUID Cache</name>
  <files>crates/y-sweet-core/src/doc_resolver.rs, crates/y-sweet-core/src/lib.rs, crates/y-sweet-core/src/link_indexer.rs</files>
  <behavior>
    DocumentResolver maintains two DashMaps:
    - path_to_doc: "Lens/Photosynthesis.md" -> DocInfo { uuid, relay_id, folder_doc_id, folder_name, doc_id }
    - uuid_to_path: "f7c85d0f-..." -> "Lens/Photosynthesis.md"

    Core behaviors to test:

    1. rebuild(docs: &DashMap<String, DocWithSyncKv>):
       - Given docs containing two folder docs (Lens with 2 files, Lens Edu with 1 file)
       - Expect: 3 entries in path_to_doc, 3 entries in uuid_to_path
       - First folder doc -> "Lens" folder name, second -> "Lens Edu"
       - Paths derived from filemeta keys: strip leading "/", prepend folder name
         e.g. filemeta "/Notes/Ideas.md" in folder 0 -> "Lens/Notes/Ideas.md"
         e.g. filemeta "/Welcome.md" in folder 0 -> "Lens/Welcome.md"

    2. resolve_path("Lens/Photosynthesis.md") -> Some(DocInfo { uuid, relay_id, ... })
       - Returns None for unknown paths

    3. path_for_uuid("f7c85d0f-...") -> Some("Lens/Photosynthesis.md")
       - Returns None for unknown UUIDs

    4. all_paths() -> Vec<String> containing all registered paths

    5. update_folder(folder_doc_id, folder_idx, docs):
       - Adding a new file to the folder doc -> resolver picks it up
       - Removing a file -> resolver drops it

    6. derive_folder_name(folder_idx) -> &str:
       - 0 -> "Lens", 1 -> "Lens Edu" (centralized, not duplicated)

    Also: make `read_backlinks_array` in link_indexer.rs `pub` (it's currently private).
  </behavior>
  <implementation>
    Use DashMap<String, DocInfo> and DashMap<String, String> for the two maps.

    DocInfo struct:
    ```rust
    #[derive(Clone, Debug)]
    pub struct DocInfo {
        pub uuid: String,
        pub relay_id: String,
        pub folder_doc_id: String,
        pub folder_name: String,
        pub doc_id: String,  // "{relay_id}-{uuid}"
    }
    ```

    rebuild() iterates all folder docs (using find_all_folder_docs pattern), reads filemeta_v0,
    extracts uuid via extract_id_from_filemeta_entry, constructs path from folder name + filemeta key.
    Clears both maps before rebuilding.

    update_folder() does the same but for a single folder doc: removes all entries for that folder_doc_id,
    then re-adds from current filemeta_v0.

    Path construction: given filemeta key "/Notes/Ideas.md" and folder name "Lens":
    - Strip leading "/" -> "Notes/Ideas.md"
    - Prepend folder name + "/" -> "Lens/Notes/Ideas.md"

    For the doc_id field, we need the relay_id. The folder doc's own doc_id has format "relay_id-folder_uuid".
    Use parse_doc_id on the folder doc's key to get relay_id. All content docs in that folder share the same relay_id.

    derive_folder_name: a simple pub fn that takes usize -> &'static str. Centralize this so server.rs
    can also use it (reducing duplication, though server.rs refactoring is optional for this plan).

    Tests use real Y.Doc creation (same pattern as link_indexer tests): create folder docs with
    filemeta_v0 entries, create DashMap, call rebuild, verify resolve_path/path_for_uuid/all_paths.
  </implementation>
</feature>

<verification>
```bash
cd /home/penguin/code/lens-relay/ws3 && CARGO_TARGET_DIR=~/code/lens-relay/.cargo-target cargo test --manifest-path=crates/y-sweet-core/Cargo.toml doc_resolver -- --nocapture
```
All DocumentResolver tests pass. The module compiles and exports DocumentResolver and DocInfo.
</verification>

<success_criteria>
- DocumentResolver::rebuild builds correct bidirectional maps from folder docs with filemeta_v0
- resolve_path returns correct DocInfo for known paths, None for unknown
- path_for_uuid returns correct path for known UUIDs, None for unknown
- all_paths returns all registered paths
- update_folder correctly adds/removes entries for a single folder
- derive_folder_name centralizes the "Lens"/"Lens Edu" logic
- read_backlinks_array is pub in link_indexer.rs
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-mcp-read-only-tools/03-01-SUMMARY.md`
</output>
